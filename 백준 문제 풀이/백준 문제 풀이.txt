# 백준 문제 풀이 적는 곳




1000. A+B


풀이

a,b = input().split()

print(int(a)+int(b))




1001. A-B


풀이

a,b=input().split()

print(int(a)-int(b))




1008. A/B


풀이

a,b=input().split()

print(float(a)/float(b))





1110. 더하기 사이클


풀이

T = int(input())
T_cheak = T
T_temp = 0
T_new = 0
T_count = 0
while 1:
    if T >=0 or T <100:
        T_temp = T//10 + T%10
        T_new = (T%10) *10 + T_temp%10
        T_count +=1
        T = T_new
    if T_new == T_cheak:
        break
print(T_count)





1330. 두 수 비교하기


풀이

a,b= input().split()

if int(a)<int(b):
    print('<')
if int(a)>int(b):
    print('>')
if int(a)==int(b):
    print('==')




1546. 평균


풀이

N = int(input())    # 과목 개수 입력
S = list(map(int,input().split()))  # 성적입력
sum_S = 0   # 새롭게 만든 성적
if len(S) !=N:  # 과목개수보다 주어진 숫자가 많거나 적을떄
    print('주어진 과목개수보다 많거나 적습니다.')
max_S = max(S)  # 주어진 과목 점수의 최댓값 
#print(max_S,len(S))

for i in range(len(S)): # 주어진 과목 개수만큼 반복
    Sm = S[i]/max_S*100     # 주어진 공식
    sum_S += Sm     # 공식을 계산한 합
result = sum_S/len(S)       # 평균 구하기
print(result)



2438. 별찍기 -1


풀이

T = int(input())

for i in range(1,T+1):
    print('*'*i)



2439. 별찍기 -2


풀이

T = int(input())

for i in range(1,T+1):
    print(' '*(T-i)+'*'*i)



2446. 별찍기 -9


풀이

T = int(input())

K = T

for i in range(1,T+1):
    print(' '*(i-1)+'*'*(2*(K-i)+1))
for j in range(1,K):
    print(' '*(K-j-1)+'*'*(2*(j)+1))



2523. 별찍기 -13


풀이

T = int(input())

K = T

for i in range(1,T+1):
    print('*'*i)
for j in range(1,K):
    print('*'*(K-j))



2557. Hello World


풀이

print("Hello World!")



2562. 최댓값


풀이

li = []
for k in range(9):
    li.append(int(input()))

print(max(li))
print(li.index(max(li))+1)



2577. 숫자의 개수


풀이

s1 = int(input())   # 1번쨰 숫자
s2 = int(input())   # 2번쨰 숫자
s3 = int(input())   # 3번쨰 숫자

sm = s1*s2*s3   # 3개의 곱

c0 = 0
c1 = 0
c2 = 0
c3 = 0
c4 = 0
c5 = 0
c6 = 0
c7 = 0
c8 = 0
c9 = 0

li_sm = list(str(sm))
for i in li_sm:
    if i == '0':
        c0 +=1
    if i == '1':
        c1 +=1
    if i == '2':
        c2 +=1
    if i == '3':
        c3 +=1
    if i == '4':
        c4 +=1
    if i == '5':
        c5 +=1
    if i == '6':
        c6 +=1
    if i == '7':
        c7 +=1
    if i == '8':
        c8 +=1
    if i == '9':
        c9 +=1

print(c0)
print(c1)
print(c2)
print(c3)
print(c4)
print(c5)
print(c6)
print(c7)
print(c8)
print(c9)




2588. 곱셈


풀이

a = input()
b = input()

b1 = int(b)%10  # 일의자리
b2 = (int(b)%100)//10   # 십의자리
b3 = int(b) //100   # 백의자리

bb1 = int(a)*b1
bb2 = int(a)*b2*10
bb3 = int(a)*b3*100

print(int(a)*b1)
print(int(a)*b2)
print(int(a)*b3)
print(bb1+bb2+bb3)




2739. 구구단


풀이

a = int(input())

for i in range(1,10):
    print(a,'*',i,'=',a*i)





2741. N찍기


풀이

N = int(input())

for i in range(1,N+1):
    print(i)




2742. 기찍N


풀이

N = int(input())

for i in range(N,0,-1):
    print(i)



2753. 윤년


풀이

a=input()

if int(a) % 4 ==0 and int(a)% 100 != 0 or int(a) %400 ==0:
    print('1')
else:
    print('0')




2884. 알람 시계


풀이


a,b = input().split()

if int(a) !=0 and int(b) >= 45:
    print(int(a),int(b)-45)
elif int(a) !=0 and int(b) < 45:
    print(int(a)-1,(60-45)+int(b))
elif int(a) ==0 and int(b) >= 45:
    print(int(a),int(b)-45)
elif int(a) ==0 and int(b) < 45:
    print(int(a)+23,(60-45)+int(b))



3052. 나머지


풀이

li = []
for i in range(10):
    S = int(input())
    ca = S%42
    li.append(ca)
li = set(li)
print(len(li))





5543. 상근날드


풀이

li_H = []   # 햄버거 가격 리스트
li_C = []   # 음료수 가격 리스트

T1 = int(input())   # 상덕버거
li_H.append(T1)
T2 = int(input())   # 중덕버거
li_H.append(T2)
T3 = int(input())   # 하덕버거
li_H.append(T3)
T4 = int(input())   # 콜라
li_C.append(T4)
T5 = int(input())   # 사이다
li_C.append(T5)

min_V = (min(li_H) + min(li_C)) - 50     # 햄버거중에 제일싼 햄버거와 제일싼 음료수가격
# 세트를 구매하면 50원 할인
print(min_V)





8393. 합


풀이

chance = int(input())
sum = 0
for i in range(chance+1):
    sum += i
print(sum)






9498. 시험성적


풀이

a= input()

if int(a) >= 90:
    print('A')
elif int(a) >= 80:
    print('B')
elif int(a) >= 70:
    print('C')
elif int(a) >= 60:
    print('D')
else:
    print("F")





10039. 평균점수 


풀이

T1 = int(input())
T2 = int(input())
T3 = int(input())
T4 = int(input())
T5 = int(input())

if T1 % 5 ==0:
    if T2 % 5 ==0:
        if T3 % 5 ==0:
            if T4 % 5 ==0:
                if T5 % 5 ==0:
                    if T1 < 40:
                        T1 = 40
                    if T2 < 40:
                        T2 = 40
                    if T3 < 40:
                        T3 = 40
                    if T4 < 40:
                        T4 = 40
                    if T5 < 40:
                        T5 = 40
                    avg = (T1+T2+T3+T4+T5)//5
                    print(avg)



10171. 고양이


풀이

print("\    /\\")
print(" )  ( ')")
print("(  /  )")
print(" \(__)|")



10172. 개


풀이

print("|\_/|")
print("|q p|   /}")
print('( 0 )"""\\')
print('|"^"`    |')
print("||_/=\\\__|")



10430. 나머지


풀이

a,b,c=input().split()

print((int(a)+int(b))%int(c))
print(((int(a)%int(c))+(int(b)%int(c)))%int(c))
print((int(a)*int(b))%int(c))
print(((int(a)%int(c))*(int(b)%int(c)))%int(c))



10718. We love kriii


풀이

print("강한친구 대한육군")
print("강한친구 대한육군")



10817. 세수


풀이

li_list = []

T1,T2,T3 = map(int,input().split())
li_list.append(T1)
li_list.append(T2)
li_list.append(T3)

li_sort = sorted(li_list)
print(li_sort[1])




10818. 최소, 최대


풀이

A = int(input())
B = list(map(int,input().split()))
if len(B) != A:
    print("개수가 틀립니다.")
else:
    print('{} {}'.format(min(B),max(B)))




10869. 사칙연산


풀이

a,b=input().split()

print(int(a)+int(b))
print(int(a)-int(b))
print(int(a)*int(b))
print(int(a)//int(b))
print(int(a)%int(b))




10871. X보다 작은 수


풀이

a,b = map(int,input().split())
c = list(map(int, input().split()))

for i in range(a):
    if c[i] < b:
        print(c[i],end=' ')





10950. A+B -3


풀이

chance = int(input())

for i in range(chance):
    a,b = map(int,input().split())
    print(a+b)





10951. A+B -4


풀이

while 1:
    try:
        a,b = map(int,input().split())
        if a>0 and b<10:
            print(a+b)
    except:
        break





10952. A+B -5


풀이

while 1:
    a,b = map(int,input().split())
    if a>0 and b<10:
        print(a+b)
    if a==0 and b==0:
        break




10996. 별찍기 -21


풀이

T = int(input())

K,C = T , T//2

for i in range(1,T+1):
    if K%2 ==1:
        print('* '*(K-C))
        print(' *'*C)
    elif K%2 ==0:
        print('* '*C)
        print(' *'*(K-C))



10998. AxB


풀이

a,b=input().split()

print(int(a)*int(b))




11021. A+B -7


풀이

import sys

T = int(input())

for i in range(1,T+1):
    a,b=map(int,sys.stdin.readline().split())
    print("Case #%d:"%i,a+b)




11022. A+B -8


풀이

import sys
T = int(input())

for i in range(1,T+1):
    a,b=map(int,sys.stdin.readline().split())
    print("Case #%d: %d + %d = %d"%(i,a,b,a+b))



14681. 사분면 고르기


풀이

a = int(input())
b = int(input())

if a > 0 and b > 0:
    print('1')
elif a < 0 and b>  0:
    print('2')
elif a < 0 and b < 0:
    print('3')
else:
    print('4')




15552. 빠른 A+B


풀이

import sys

T = int(input())

for i in range(T):
    a,b = map(int,sys.stdin.readline().split())
    print(a+b)


8958. OX 퀴즈


풀이

N = int(input())    # 계산해야할 경우의 수
for i in range(N):
    S = list(input())  # OX 리스트 
    su = 0
    cnt = 1

    for i in S:
        if i == 'O':
            su +=cnt
            cnt +=1
        else:
            cnt=1
    print(su)




4344. 평균은 넘겠지


풀이

N = int(input())    # 계산해야할 경우의 수
for i in range(N):
    S = list(map(int,input().split()))  # 점수 문자열
    avg = (sum(S) -S[0]) / S[0]   # 평균
    cnt = 0 # 평균을 넘는 학생들
    for k in range(1,len(S)):
        if S[k] > avg:
            cnt +=1
    print('%0.3f'% round(cnt/S[0]*100,3),'%',sep='')   #sep를 쓰면 가운데에 문자를 집어넣을수있다.



15596. 정수 N개의 합


풀이

def solve(a):
    ans = 0
    li_a = list(a)
    for i in range(len(a)):
        ans += li_a[i]
    return ans





4673. 셀프 넘버


풀이

n_num_set = set(range(1,10001)) # 1~10000까지의 전체의 숫자를 중복제거 and 정렬 

G_num_set = set()   # 셀프넘버를 제외한 나머지 숫자들 담기

for i in range(1,10001):    # 이제 1~10000큼 반복
    for k in str(i):    # 셀프넘버가 아닌것들 찾기
        i +=int(k)
    G_num_set.add(i)    # 추가

self_num_set = n_num_set - G_num_set    # 전체 - 셀프넘버가 아닌것 = 셀프넘버

for i in sorted(self_num_set): # 구해준 셀프넘버를 정렬 해줌
    print(i)    # 출력




1065. 한수


풀이

n = int(input())
su = 0

for i in range(1, n+1):
    if i <= 99:		# 1부터 99까지는 모두 한수
        su +=1
    else:
        ns = list(map(int,str(i)))	# 자릿수대로 분리
        if ns[0] - ns[1] == ns[1] - ns[2]:	# 등차수열인지 확인
            su +=1		# 등차수열이면 한수 이므로 증가
print(su)	


11654. 아스키 코드


풀이

n = input()

print(ord(n))



11720. 숫자의 합


풀이

n = int(input())

p = list(map(int,input()))

if n == len(p):
    print(sum(p))



10809. 알파벳 찾기 (나중에 다시풀어보기)


풀이

# 문제가 해당 알파벳 문자열의 위치를
# 0부터 ~ 길이까지 해당 자리숫자를
# 알파벳 전부를 포함되어있지않으면 -1 이므로
# -1로 설정하고 abc~xyz 순으로 몇번쨰 자리인지 표기만 해주면된다.

str_n = input() # 문자열 입력
str_check = [-1]*26 # 체크 배열 해당하지않은것들은 -1 

for i in range(len(str_n)): # 문자열 길이반큼 반복
    if str_check[ord(str_n[i])-97] != -1:   # 문자가 중복됬을시 계속반복
        # -1이면 다음으로 반복
        #print('1.테스트', i, ord(str_n[i])-97) #테스트
        continue
    else:
        print('ㅎㅇ')
        str_check[ord(str_n[i])-97] = i
for i in range(26):
    print(str_check[i], end=' ')




2675. 문자열 반복


풀이


T = int(input())

answer = []
for i in range(T):
    T_t = input().split()
    li_t =list(T_t[1:])
    for k in range(len(li_t[0])):
        na = int(T_t[0]) * li_t[0][k]
        answer.append(na)
        b = "".join(answer)
    print(b)
    answer = []




1157. 단어 공부


풀이


S = input().upper() # 받은문자열 대문자로 통일
ABC = []    # 알파벳 개수 저장

for i in set(S):    # 중복제거하고
    ABC.append(S.count(i))  # 문자 개수를 배열에 보낸다.

idx = [i for i,x in enumerate(ABC) if x==max(ABC)]    # 최댓값 위치
# x가 최댓값 i가 위치
#print('1.test',list(set(S)))    # test
#print('2.test',ABC.index(max(ABC))) # test

if len(idx) > 1: print('?') # 최댓값이 여러개면 ? 출력
else: print(list(set(S))[ABC.index(max(ABC))])  # 최댓값이 1개라면 그대로출력



1152. 단어의 개수



풀이

S = list(input().split())
print(len(S))





2908. 상수



풀이

a,b = input().split()

a = int(a[::-1])
b = int(b[::-1])

if a> b:
    print(a)
else:
    print(b)



5622. 다이얼



풀이

li = ['ABC','DEF','GHI','JKL','MNO','PQRS','TUV','WXYZ']
    # 단어를 리스트로 넣어놓음
st = input()        # 문자열 입력

st_sum = 0  # 걸리는 시간 총합


for i in range(len(st)):    # 문자열 받은 길이만큼 반복
    for k in li:    # li 를 반복
        if st[i] in k:  # 받은 문자열을 점검할떄 k라면 걸리는시간에 위치+3(0부터시작하기떄문에 +1 이고
            #시작할때 1초까지걸린느시간이 +2 이므로 총 3초 시작할때마다 3초가걸림 그래서 +3이다.)
            st_sum += li.index(k)+3
print(st_sum)




2941. 크로아티아 알파벳


풀이

#이런류 문제 풀떄 replace 참고 해보기 

li = ['c=','c-','dz=','d-','lj','nj','s=','z='] # 변경된 크로아티아 알파벳
    # 단어를 리스트로 넣어놓음
st = input()        # 문자열 입력
for i in li:
    st = st.replace(i,'a')
print(len(st))






1316. 그룹 단어 체커


풀이

# 중복 단어나 그룹단어 찾는데 find 함수 참고 해보기


T = int(input())    # 반복할 정수 입력
for i in range(T):  # 정수만큼 반복
    s = input()     # 문자열 입력
    for k in range(1,len(s)):   # 문자열 길이만큼 반복 
        # 문자열 위치를 반환 해서 앞에 나왔던 문자가 뒤에 또나오게되면
        if s.find(s[k-1]) > s.find(s[k]):  
            # 그룹단어가 아니기떄문에   -1 해줌
            T -= 1
            break

print(T)




1712. 손익 분기점

풀이

A,B,C = map(int,input().split())

break_point = 0

if(C <= B):
    break_point = -1
else:
    break_point = A // (C-B) +1 # +1 은 최초로 이윤이 나기시작하는 시점임

print(break_point)




2839. 설탕 배달


풀이


def su(T):
    for i in range((T//3)+1):
        for k in range((T//5)+1):
            if ((5*k + 3*i) == T):
                return i + k

    return -1

T = int(input())
print(su(T))





2292. 벌집

# 벌집 개수를 보면서 수열 등 규칙찾기

풀이

N = int(input())

first_cnt = 1   # 답으로 환산할 cnt
cnt = 1 # 개수를 계산할 cnt
su_six = 6

while N > cnt:
    first_cnt +=1
    cnt += su_six
    su_six += 6
print(first_cnt)



1193. 분수찾기

풀이






2869. 달팽이는 올라가고 싶다.


내풀이(시간초과)


# 달팽이는 올라가고싶다.
# 높이가 V 미터인 나무막대기
# 낮에는 A 미터 올라감  밤에 자는동안 B미터 미끄러진다.
# 정상에 올라간후 미끄러지지않음  


A,B,V = map(int,input().split())

day = 0
sum_V = 0
while 1:
    day +=1
    sum_V += A
    if sum_V < V:
        sum_V -= B
    if sum_V == V:
        break
print(day)



정답 풀이

##  a*k-b*(k-1) => v 를 정리한 식이 k>=(v-b)/(a-b) 임

A,B,V = map(int,input().split())

k = (V-B) /(A-B)        # 막대높이에서 미끄러진만큼 / 올라가는 높이 - 미끄러지는 높이
print(int(k) if k == int(k) else int(k)+1)

# 계산에서 4.2일 이런식으로 분수가 나올수있다 이것을 방지하기위해 +1을 해준다.






2775. 부녀회장이 될테야


풀이


test_case = int(input())

for i in range(test_case):
    k = int(input())    # 층
    n = int(input())    # 호

    human = [k for k in range(1,n+1)]   # 1호 부터 n+1 호 까지 반복 사람숫자
    for j in range(k):  # 층수 반복
        for l in range(1,n):    # 그 층수의 호수 까지 사람수 세기
            human[l] += human[l-1]  # 1호 2호 3호 ... 모든 사람수 세기
    print(human[-1])    # 맨마지막 -1 반환




1978. 소수찾기

풀이


N = int(input())    # 테스트 케이스 정수
Ns = list(map(int,input().split())) # 해당 소수 정수 입력
result = 0  # 결과값

for i in Ns:    # 문자열 ns를 반복
    cnt = 0     # 소수개수 카운트
    for j in range(1,i+1):  # 1,i+1 까지 반복
        if i %j ==0:    # i%j ==0 일떄 소수이므로 
            cnt +=1     # 카운트 증가
    if cnt == 2:        # cnt == 2 라는것은 소수는 1과 자기자신 밖에 없기때문
        result +=1      #그래서 2개가 쌓였을떄 소수이므로 result에 1을 더한다
print(result)   # 그리고 출력



2581. 소수

풀이

M = int(input())    # M 정수
N = int(input())    # N 정수
li_mn = []  # 최솟값을 찾는 list 

for i in range(M,N+1):    # 받은 최소 M과 최대 N+1 만큼 반복
    cnt = 0     # 소수개수 카운트
    for j in range(1,i+1):  # 1,i+1 까지 반복
        if i %j ==0:    # i%j ==0 일떄 소수이므로 
            cnt +=1     # 카운트 증가
    if cnt == 2:        # cnt == 2 라는것은 소수는 1과 자기자신 밖에 없기때문
        li_mn.append(i)      #그래서 2개가 쌓였을떄 소수 li_mn에 추가
if len(li_mn) != 0:         # 길이가 0일떄와 1이상일떄
    print(sum(li_mn))       # 합 
    print(li_mn[0])         # 그중 최소값
else:
    print('-1')             # 길이가 0이면 -1 출력




1929. 소수 구하기

풀이

M,N = list(map(int,input().split(' ')))

    # 정수 M과 N을 입력 사이에 공백이 있어야하므로 ' ' 해줌

def is_p(num):      # 소수 판별 함수를 만듦
    if(num <= 1):       # 받은 정수가 1이거나 1보다 작을떄
        return False    # False 반환

    i = 2               # i라는 변수에 2를 정의

    while i*i <= num:       # i*i 를 했을떄 주어진 정수보다 같거나 작으면
        if num % i ==0:        # 정수의 i의 나머지를 구한다.
            return False    # 그리고 나머지가 0이라면 False을 반환
        i +=1           # i를 1 증가시킨다.
    return True         # 나머지가 0이아니라면 True 반환
for i in range(M,N+1):      # 이제 주어진 최소 최대 변수 사이만큼 반복
    if(is_p(i)):        # 주어진 if문이 함수내에서 참(True) 일떄
        print(i)        # print(i)를 출력





1193. 분수찾기

풀이

x = int(input())        # 몇번쨰 숫자 입력

line = 1                # 줄 바꿈

while x >line:          # 해당 줄보다 숫자가 클떄 반복
    x -= line           # 줄만큼 x를 뺀다.
    line +=1            # 줄을 1씩 더하고

if line %2 ==0:         # 해당 숫자가 짝수일때
    a=x
    b=line -x+1		# a가 위로 b가 아래
else:                   # 해당 숫자가 홀수일떄
    a = line -x +1
    b=x

print(a,'/',b,sep='')




10250. ACM호텔

풀이


for _ in range(int(input())):
    H,W,N = map(int,input().split())    # H 층  W 호 M 사람
    di = N//H+1        # 01호부터 채우는 방식 이므로 00호는 없으므로 +1 부터 시작
    fl = N%H        #  층 수 나머지로 돌림
    if fl == 0: # 딱 나누어 떨어질떄
        di -=1      # 맨꼭대기에 사람 보내므로 -1
        fl = H  # 맨 꼭대기
        
    print(fl*100+di)        #fi 는 층이므로 *100
                            # di는 호수




1011. Fly me to the Alpha Centauri

#아직 덜이해됨 나중에 한번더 풀어보기
풀이


for _ in range(int(input())):
    a,b = map(int,input().split())    # x와 y의 거리
    c = b - a        # x와 y의 거리 차
    num = 1        #  1 정의	카운트
    while 1:
        if num **2 <=c<(num + 1)**2:		# 규칙떄문에 num**2 부터 카운트 증가
            break       # 도달 하게되면 멈춤		#  num**2보다 같거나 크고   (num+1)**2 보다 작으면 중지
        num +=1			# num은 1씩 계속 증가시켜주고
    if num **2 ==c:				# num**2 와 같으면 (num*2)-1 해줌
        print((num*2)-1)
    elif num**2 <c<=num**2+num:		# 이경우
        print(num*2)					# num*2 만
    else:					# 나머지 경우는
        print((num*2)+1)			# num*2 +1 을 해준다.


# 이해하기 쉽게 설명

# 정수화한 제곱근을 num 이라고하고(9라면 num은 3)
# 규칙에서 작동횟수 증가가 5 7 10 13 에서 이루어졌으므로 잘보면
# 2*2+1  ,  2*3+1     3*3+1     3*4+1   이믈호

# num * (num1(num보다 같거나 1큰수) +1) 이다.
# 따라서  거리가 같거나 큰값이라면
# 2num +1 이다.	(그래서 num**2 +num이 나옴)






4948. 베르트랑 공준
# 다시 풀어보기 이해안됨

풀이
# 이풀이는 시간초과 뜬다.

# 에라토스테네스의 체로 소수를 구하면
# 최대 n은 123456이 된다. 
# 2n은 246912 이다. 

n = [x for x in range(1,246913)]    # 2n개의 리스트
n.insert(0,1)   # 리스트 맨앞에 1을 넣어줌

for i in range(2,246913): # 2~2*n보다 큰 배수
    j=2 # 자기보다 큰배수를 구하기위해 설정
    while 246912 >=i*j:
        n[i*j] = 1 # 배수는 1로
        j +=1 # 다음배수

while 1:    # 소수를 처음에 구한다. 1~ 123456*2
    na = int(input())
    if na<=0:
        break
    cnt = 0
    for k in n:
        if k !=1 and na<k and k<=2*na:
            cnt +=1
    print(cnt)




풀이 2

# 성공


import math

def isPrime(num): # 소수 판별 함수
    if num ==1: return False    # num이 1 이면 소수가 아니므로 False

    for i in range(2, int(math.sqrt(num))+1):   # 2부터 num의 제곱근 +1 만큼 반복
        if num %i ==0: return False     # 나누어 떨어진다면 소수가 아니므로 False

    return True                 # 위의 나머지경우가 아니라면 소수이므로 True


li = list(range(2,246912))      # n부터 ~ 2n까지의 소수의 모든 경우를 구한다.
prime_li = []           # 리스트를 하나 만들어놓는다.

for i in li:        # 모든 소수 에서 하나씩 돌려서 prime_li에 True , False 로 소수를 판별한다.
    if isPrime(i):
        prime_li.append(i)      # 만약 True면 if 문이 실행되어 소수가 저 리스트 속에 추가된다.

while 1:
    answer = 0          # 답 변수 0 설정
    n = int(input())        # 정수 입력
    if n ==0: break     # n==0일떄 중지

    for i in prime_li:      # 이제 리스트에 추가된 소수들중 조건에 맞는것을 추리면된다.
        if n<i<=2*n:
            answer +=1          # 조건에맞는 소수들을 찾을떄마다 answer을 1씩 증가시킨다.
    print(answer)




9020. 골드바흐의 추측

풀이

# 골드 바흐의 추측

import sys			( 런타임에러 )

def check():    # 1하고 2는 소수가 아니고 3부터 소수 
    #10002는 4부터 10000까지의소수의 개수
    che = [False,False] + [True] * 10002

    for i in range(2,10002):
        if che[i]:
            for j in range(2*i, 10002, i):      # 소수 판별
                che[j] = False

    T = int(input())        # test case

    for k in range(T):      # 반복
        num = int(input())

        A = num//2      # 받은 숫자 반으로 나누고
        B = num

        for i in range(10000):
            if che[A] and che[B]:       # 만약 che[A] 와 che[B] 가 소수라면 A,B 출력 
                                        #아니라면 A는 -1 B는 +1 로 서서히 찾아감
                print(A,B)
                break

            A -=1
            B +=1

check() 




또다른 풀이


prime_list = [False, False] + [True]*10002		# 1,2는 소수가아니므로 False	1, 2를 제외한 전부를 True로 설정
					# 3~10000까지의 전체 숫자개수는 10002개 이므로 *10002
for i in range(2, 10002):			# 전체개수만큼 반복
    if prime_list[i]:				# 숫자 전체를 반복문을 돌려 짝수 즉 소수가아닌것들은
        for j in range(2*i, 10002, i):		# False 선언
            prime_list[j] = False			

T = int(input())			# test case 를 받음

for i in range(T):			# 받은만큼 반복
    n = int(input())			# 우리가 출력해야할 숫자
    a = n//2			# 받은 숫자를 반으로 나누기
    b = a 
    while a>0:			# 반으로 나눈숫자를 -1씩 하면서 반복문을 돌리므로 0이되면 종료
        if prime_list[a] and prime_list[b]:	# prime_list[a] 와 prime_list[b]  가 True 즉 소수 라면
            print(a, b)			# a,b 출력
            break			 #중지
        else:				# 소수가 아니라면 a를 -1감소 b를 +1증가 시키기
            a-=1
            b+=1


# 즉 1,2는 소수가 아니므로 False 선언하고 나머지 3~10000까지 개수가 10002개 이므로 이만큼 반복하고
# 만약 해당 숫자가 짝수라면 Flase 선언으로 바꿔주고
# 테스트케이스 횟수 입력 그리고 우리가 구할 숫자를 입력받고 그 숫자를 //2 해준다 그리고 b에 저장
# 그리고 리스트[a] 와 리스트[b]가 True 일경우 print(a,b) 출력 True 가 아니라면 a를 -1해주고 b에 +1해준다.


1085. 직사각형에서 탈출

풀이

x,y,w,h = map(int,input().split())		# x,y,w,h 입력 받기 

l_i = [x,y,w-x,h-y]			# 대각선 최소값을 구하기위해 원래의 x,y좌표
print(min(l_i))			# 그리고 최대 끝의 값 w,h를 받고 w-x, h-y 를 해주고
				# 최소값 즉 min을 구해주면 된다.


# x,y , w,h 를 각각 입력받고. 대각선의 최소값을 구하려면 본래 x,y좌표에 맨 꼭지점 즉 최대크기에서
# x와 y를 빼주면된다. 즉 [x,y,w-x,h-y] 를 해주고 이 리스트중 최소값을 구하고 출력하면 된다.

3009. 네 번째 점


풀이


li_x = []				# 리스트 x y 를 만들어줌
li_y = []
for _ in range(3):			# 3번 반복
    a,b = map(int,input().split())		# 정수 입력 받고
    li_x.append(a)			# 리스트에 보내기 
    li_y.append(b)

for i in range(3):
    if li_x.count(li_x[i]) == 1:		# 그리고 개수가 1개 밖에 없는 (중복이되면 안되니 ㅇㅇ)
        x1 = li_x[i]			# 것을 찾고 그대로 출력
    if li_y.count(li_y[i]) == 1:
        y1 = li_y[i]

print(x1,y1)

# 리스트 x와 리스트 y를 만들어준다. 그리고 3번반복해야 하므로 3번반복문을 선언하고
# 정수 a,b 를 map함수를 통해 입력받는다. 그리고 내가만든 리스트에 추가한다.
# 그리고 이제 네번쨰점을 만드는데 서로 중복이 되면 안되므로 리스트내부에서 개수가 1개인 정수를 
# 찾아야한다. 따라서 count == 1을 이용해서 구한다. x1 , y1 변수로 설정해서 구하고 그대로 출력하면 된다.


4153. 직각삼각형


내 풀이	( 실패 )

# 피타고라스의 정리

while 1:
    x,y,z = map(int,input().split())

    if x == 0 and y == 0 and z == 0:
        break

    su = x**2 + y**2
    re = z**2

    if su == re:
        print('right')
    else:
        print('wrong')




# 알맞는 풀이



# 피타고라스의 정리

while 1:
    li = list(map(int,input().split()))		# 문자열 입력받고
    max_li = max(li)				# 최댓값 즉 빗변의길이 크기떄문에 따로 빼낸다.
    if sum(li) == 0:				# 0 0 0을 입력받을시 종료
        break

    li.remove(max_li)				# 리스트에서 최댓값 제거

    if li[0]**2 + li[1] **2 == max_li**2:		# 피타고라스의 정리 공식 이용
        print('right')
    else:
        print('wrong')


# 직각삼각형 즉 피타고라스의 정리를 이용해서 푸는 문제이다.
# 0 0 0을 받으면 종료이므로 while 1 로 무한반복문을 돌리고 리스트를 만들어 입력하는 문자열을 받게한다.
# 그리고 그 리스트중 최댓값이 빗변이기 떄문에 최댓값을 따로 뺴낸다.
# 다음 리스트에서 최댓값을 제거하고 따로 sum(li) == 0 이면 종료 문을 만든다.
# 이제 피타고라스의 정리를 이용해서 right , wrong를 출력해주면된다.
# li[0]**2 + li[1] **2 == max_li **2


3053. 택시 기하학


풀이

# 유클리드 기하학

import math # 파이를 써야하기 떄문


r = int(input())    # 반지름 입력

print(r*r*math.pi)  # 원의 넒이
print(r*r*2)    # 택시 기하학


#택시 기하학은 사각형이다 즉 반지름 r*2 을 하면 
# 삼각형의 넒이 이므로 나머지 반쪽 삼각형까지 *2 해주면 된다.




1002. 터렛


풀이


# 터렛

#문제 설명

# a,b 두사람의 좌표가 주어지고 a가 계산한 b와의 거리 r1
# b가 계산한 a와의 거리 r2 가 주어졌을때 b가 있을수있는 
# 좌표를 구하라

# 원의 접점의 관한 문제이다.
# 이경우 4가지의 경우의 수가있다.

# 원이 겹치는 경우 , 한원이 다른원을 포함한경우 
# 좌표가 달라 원이 떨어져있는경우 
# 
# 한점만 겹치는 경우 , 겹치는점이 2개인 경우
# 아예 떨어져있는경우 r1+r2 보다 큰 경우

test = int(input())

for _ in range(test):

    a1,b1,r1,a2,b2,r2 = map(int, input().split())
    # 나는 제곱근 선언할 예정

    d = ((a1-a2)**2+(b1-b2)**2)**0.5	# 제곱근 선언

    rsu = r1 + r2
    rmu = abs(r2 - r1)  # 음수가 나오면 안되므로 절댓값 함수 abs를 사용

    if d == 0:      # 거리가 0이라는 것은
        if r1 == r2:    #  원이 겹친다라는 뜻이다. 따라서 만나는점은 무수히 많으므로 -1을 출력
            print(-1)       # 나머지경우는 만나지 않는 경우이므로 0을 출력
        else:
            print(0)

    else:
        if d== rsu or d == rmu:     # d 가 0이 아니라면 즉 중심위치가 다를떄!
            print(1)                # 만약 rus rms 가 같다면 접점은 1개이므로 1을 출력
        elif d < rsu and d > rmu:   # 그게아니고 rus 즉 합이 거리보다 크고 거리보다 rmu가 작으면 즉 원이 겹치는 경우
            print(2)
        else:
            print(0)        # 그외의경우는 없다.




10872. 팩토리얼


풀이


# 팩토리얼

# 팩토리얼 알고리즘 공식

def jagi(N):		# 함수하나 만들기
    if N <= 1:		# 받은 숫자가 1보다 같거나 작으면 1을 반환
        return 1
    else:			# 1이 아니라면 재귀함수 돌리기
        return N*jagi(N-1)	# 받은 숫자에다가 그 숫자에 -1하고 다시 볼리기 1이 될떄까지

num = int(input())

print(jagi(num))




10870. 피보나치 수 5


풀이


# 피보나치


def jagi(N):			#  피보나치 알고리즘 공식
    if N ==0:
        return 0
    elif N ==1:
        return 1
    else:
        return jagi(N-1) + jagi(N-2)

num = int(input())

print(jagi(num))





2447. 별 찍기 -10


풀이
	# 3의 거듭제곱!!
	# 크기 3의 패턴에 가운데 공백이 존재
import sys 

num = int(input())		# 정수 입력받고

def star(x,y):		# 함수하나 만들자
    while(x !=0):		# x가 0이 아닐때까지
        if(x%3==1 and y%3==1):	# 받은 x와 y가 나머지가 1일떄	(즉 2번째줄 0 1 2 이기떄문)
            sys.stdout.write(' ')		# 가운데 이므로 공백을 입력
            return None		# 그리고 None 반환

        x = x//3			# 이것을 마치고 x와 y를 3의 거듭제곱이기 때문에
        y = y//3			# //3씩 나눠준다.
    sys.stdout.write('*')		# 그리고 위의경우가아니라면 *을출력 이것을 반복한다.

for x in range(num):			# x줄에 y만큼 반복 끝나면 개행출력
    for y in range(num):
        star(x,y)
    sys.stdout.write('\n')





11729. 하노이 탑 이동 순서


풀이


# 하노이의 탑 이동 순서

n = int(input())

def hanoi(n,x,y,z):
    if n ==1:
        print(x,z)  # 만약 쌓여있는게 1개라면

    else:
        hanoi(n-1,x,z,y)    # 하노이 계층이 2개 이상이라면
        print(x,z)          # 3번쨰와 2번쨰를 바꿔주고 첫번째와 세번쨰를 출력
        # 이동경로
        hanoi(n-1,y,x,z)    # 그리고 두번쨰와 세번쨰를 바꿔주면 된다.

su = 1

for i in range(n-1):
    su = su*2+1         # 두번씩 이동하고 (*2) 마지막에 한번이동 +1

print(su)   # 총 옮긴 횟수 출력
hanoi(n,1,2,3)





2789. 블랙잭

풀이

# 블랙잭

# 첫쨰줄에 n1과 n2을 받고
# 숫자들을 입력 한다.
# 반복문을 돌려 3개를 일일이 돌린후 
# if 문으로 n2 보다 같거나 작은것과 n2에서 세개의 합을 뺀것이 n2에서 
# answer을 뺀것보다 작은것들을 거르면 된다.
# 그리고 그값을 변수에 저장시키고 출력한다.
				
n1,n2 = map(int,input().split())			# n1 , n2 를 출력할 문자열
num = list(map(int,input().split()))		# 두번쨰 문자열 리스트화

answer = 0		# 답 을 합산할 변수

for i in range(0,n1-2):		# 반복문 돌림 n1 -2 만큼 총 3번 돌려야하기 떄문
    for j in range(i+1,n1-1):		# 두번쨰 n1-1
        for k in range(j+1,n1):		# 세번쨰 n1
            if (num[i]+num[j]+num[k]) <=n2 and n2 - (num[i]+num[j]+num[k]) < n2 - answer:	
		# 이제 블랙잭 규칙대로 이프문을 짜면됨 합이 n2보다 같거나 작고
		# n2- 합 이 n2-answer 보다 작으면 된다.
	              answer = num[i]+num[j]+num[k]
print(answer)




2231. 분해합


풀이


num = int(input())		# 숫자를 입력받고

print_N = 0		# 답으로 출력할 변수 생성

for i in range(1,num+1):		# 반복문 num+1 만큼
    d_N = list(map(int,str(i)))		# i를 str화시키고 리스트화시켜서 더함
    sum_N = i + sum(d_N)		# 계속해서 자릿수 합을 더한다.
    #print('1.',i, sum_N)		
    #print('2.',d_N, )
    if (sum_N == num):		# 그리고 그합이 처음입력했던 생성자 즉 값이 나오면
        print_N = i			# 변수에 i를 저장하고 중지
        break

print(print_N)			# 출력




7568. 덩치


풀이


# 덩치

# 몸무게가 x   키가 y

#  덩치는 (x,y)

# 두사람이 A , B 주어짐 >>  (x,y)   ,   (p,q)

# x > p and y > q 라면 A가 B보다 더 크다 라고 정할수있다.

# 예외의 경우는 C(45,181)     ,   D(55,173)   같은
# 몸무게는 D가 더 무겁고 키는 C가 더 크므로 덩치로 볼떄
# 누구도 상대방이 더크다고 말하지 못한다.

# N집단에서 큰덩치의 사람의 수로 정해짐

# 따라서 자신보다 더큰 덩치 사람이 k명 이면 그사람의 덩치수는
# k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진
# 사람은 여러명도 가능 나머지 예시 참조


# 즉 제일 독보적으로 큰애 C 는 1등이고
# 그다음 몸무게가 무거운것은 D인데 D보다 키가큰 A와B가 있으므로
# 우열을 가릴수없다 그래서 동레벨이다

# 나머지 E는 순위에서 밀렸으므로 5이다.

# 이제 구해보자면 대략 풀이

# 먼저 전체 사람수 N을 입력 받고
# 몸무게와 키를 입력 받는다. 
# 입력받고 바로 반복문을 돌릴수 있게 해야한다.
# 또한 이러한과정에서 답을 구하는과정이 맞지만 출력이 아닐떄는
# 수정하면 된다.

# 입력 받은것들을 다 리스트에 저장해서 각각 비교해서 순위를
# 지정해주면 될것같다.


N = int(input())			# 반복 횟수 입력 받고
li_TM = []				# 몸무게와 키를 저장할 리스트
for _ in range(N):			# 반복문 돌려서 키와 몸무게 입력받고 저장
    T,M = map(int,input().split())
    li_TM.append((T,M))


for i in li_TM:			# 리스트 길이 만큼 반복
    rank = 1			# rank 를 1로 잡고 1등 2등 이렇게 시작하므로
    for j in li_TM:			# 비교해야하므로 이중반복문
        if i[0] < j[0] and i[1] < j[1]:	# 몸무게는 몸무게 키는 키끼리 비교후 해당이 된다면 
            rank += 1			# rank 1증가
    print(rank, end=' ')		# 해당이 되지않는다면 그대로 rank 출력




1018. 체스판 다시 칠하기


풀이

# 문제 풀떄 조건문 주의하고
# 리스트 범위도 잘체크할것


n,m = map(int,input().split())		# M N 개 단위 즉 M * N  을 입력 받는다.

lis = []				# 색깔로 칠해져있는 사각형을 받을 리스트를 만든다.
min_lis = []			# 나중에 구하고 그중 최소값을 판별해낼 리스트

for _ in range(n):			# n의 횟수만큼 반복문을 돌려서 입력받음
    lis.append(input())

for i in range(n-7):			# 지민이가 총 8*8 크기의 체스판으로 잘라냈기때문에
    for j in range(m-7):		# 반복문에서 -7 해준다. (원래 마지막m-1 이기때문)
        id1 = 0			# 이제 다른색으로 칠하기 위해 변수 두개를 설정한다.
        id2 = 0
        for k in range(i, i+8):		# 8*8 이므로 이제 내부에서 칠해야하므로 i에서부터 i+8 까지
            for p in range(j,j+8):		# 여기도 같은 이유이다.
# 이부분 8*8 범위를 B와 W로 번갈아 가면서 검사
                if (p+k)%2 ==0:		# p와 k를 더했을때 짝수 이면
                    if lis[k][p] != 'W': id1+=1	# 하얀색인지 검은색인지 점검해야한다. 
# id1은 하얀색으로 시작했을때 칠해야할 부분이고
# id2는 검은색으로 시작했을때 칠해야할 부분이다.
                    if lis[k][p] != 'B': id2+=1	# 짝수 일떄 만약 검은색이라면 id1에 1을 증가시키고 하얀색부분을 id2 를 1증가하고 
                else:
                    if lis[k][p] != 'B': id1+=1	# 그외의 경우라면 하얀색에 id1 에 1증가하고 검은색에 id2에 1증가시킨다.
                    if lis[k][p] != 'W': id2+=1
        min_lis.append(id1)		# 값을 최소값판별 리스트에 보낸다.
        min_lis.append(id2)		# id1 , id2 둘다 보냄
print(min(min_lis))		# min함수를 이용해 최솟값 판별






1436. 영화 감독 숌


풀이


N = int(input())		# N번쨰 작품을 받을 변수
Mo = 666			# 종말의숫자 666을 넣어야할기떄문에 초기값 666 설정
while N:			# N이 0이 될때까지 무한 반복문 돌리고
    if "666" in str(Mo):	# 우리가 설정했던 변수가 666이라는 1666도 10666도 괜찮다
        N -=1		# 666만 존재하면 if문 성립
    Mo +=1		# 즉 N-1 줄이고 초기값 +1 을 해준다 이러한식으로 종말의 숫자가 들어간
print(Mo-1)		# 작품을 찾는다.
			# 다찾고나서 마지막것은 빼야하므로 -1 해주면 된다.


# 즉 변수를 받고 초기값 666 설정
# 제어문을 걸고 666이 나올때까지 반복문 수행 나오면 N-1 을 해주면서 카운트를 줄이고
# 나오지않으면 계속해서 초기값 +1 을 해줌 계속해서 나와서 N이 0이되는 그시점의 값에서
# -1을 해주면 그것이 답이다.


## 집에 내가 풀던거있음 집에가서 그대로 복사하기


2750. 수 정렬하기


풀이


# 정렬하기

N = int(input())		# 정수를 받고

li = []			# 빈 리스트를 하나 작성

for _ in range(N):		# 받은 정수만큼 반복하고
    num = int(input())	# 그만큼 정수를 받고 리스트에 보냄
    li.append(num)

li.sort()			# 리스트 정렬

for i in li:			# 리스트 순서대로 출력
    print(i)




2751. 수 정렬하기 2


풀이
# input 보다 readline 이 빠름

# 정렬하기

import sys		# sys 함수를 이용해서 빠르게 출력

N = int(input())

li = []

for _ in range(N):
    li.append(int(sys.stdin.readline()))

for i in sorted(li):
    sys.stdout.write(str(i)+'\n')






10989. 수 정렬하기 3


풀이


import sys

N = int(sys.stdin.readline())    # 반복 횟수 

b = [0] * 10001     # 총 갯수 정해줌

for i in range(N):      # 한계의 배열을 만들어놓고
    # 그 해당숫자가 입력되었을때 개수를 카운트
    b[int(sys.stdin.readline())] +=1

for i in range(10001):
    if b[i] != 0:   # 배열안의 개수가 0이 아니라면 즉
        # 최소한 1개 이상 존재한다면
        for j in range(b[i]):   # 그개수만큼 반복 출력
            print(i)





2108. 통계학


풀이


import sys 
from collections import Counter	# Counter 함수 리스트 원소의 개수가 알고싶을떄 쓰는 함수
				# 딕셔너리로 바꿔줌

#main
t = int(sys.stdin.readline())

numbers = []
for _ in range(t):
    numbers.append(int(sys.stdin.readline()))
    
def mean(nums):
    return round(sum(nums)/len(nums))

def median(nums):
    nums.sort()
    mid = nums[len(nums)//2] # nums의 개수는 홀수
    
    return mid

def mode(nums):
    mode_dict = Counter(nums)
    modes = mode_dict.most_common()    
    
    if len(nums) > 1 : 
        if modes[0][1] == modes[1][1]:
            mod = modes[1][0]
        else : 
            mod = modes[0][0]
    else : 
        mod = modes[0][0]

    return mod
        
def scope(nums):
    return max(nums) - min(nums)

print(mean(numbers))
print(median(numbers))
print(mode(numbers))
print(scope(numbers))



1427. 소트 인사이드


풀이


Num = input()		# 문자열 정수 입력

list_Num = list(Num)		# 문자열 받은것을 리스트로 바꿈

list_Num.sort(reverse=True)	# 받은것을 역순으로 바꾸고

#print(list_Num)
print(''.join(list_Num))	# join으로 합쳐서 출력





11650. 좌표 정렬하기


풀이


N = int(input())

li_N = []       # 빈 리스트

for _ in range(N):
    li_N.append(list(map(int,input().split())))     # 받을 정수들을 받고 리스트화시켜줌

li_N = sorted(li_N, key= lambda x : (x[0],x[1]))        # sorted 로 오름차순 정렬해주고 기준은 x[0]즉 x 와 x[1] 즉 y 를 기준으로 정렬

for i in li_N:      # 리스트 [ ] 커버 * 으로 없앨수있음
    print(*i) 





11651. 좌표 정렬하기 2

# 좌표 정렬하기 1 문제와 완전 정반대문제 정렬하는 위치만 바꿔주면 쉽게 해결된다.

풀이



N = int(input())

li_N = []       # 빈 리스트

for _ in range(N):
    li_N.append(list(map(int,input().split())))     # 받을 정수들을 받고 리스트화시켜줌

li_N = sorted(li_N, key= lambda x : (x[1],x[0]))        # sorted 로 오름차순 정렬해주고 기준은 x[1]즉 y 와 x[0] 즉 x 를 기준으로 정렬

for i in li_N:      # 리스트 [ ] 커버 * 으로 없앨수있음
    print(*i) 





# 8/27 학교에서 아침에 풀기


1181. 단어정렬


풀이


list_case = []		# 이제 입력할 문자열을 받을 리스트 생성

srot_list_case = []		# 입력한 문자열을 정렬하고 담을 리스트 생성

for i in range(int(input())):		# 입력한 정수만큼 반복
    list_case.append(input())		# 문자열 입력

set_list_case = list(set(list_case))		# 중복 제거

for j in set_list_case:
    srot_list_case.append((len(j),j))		# 정렬할 문자열을 담을 리스트에
				# (len(j) , j)
				# 길이  문자열
				# 형식으로 저장한다.
srot_list_case.sort()			# 그리고 그대로 sort로 오름차순 정렬

for len_case , case in srot_list_case:	# 형식은 길이와,문자열 이므로 for 길이 , 문자열 in 리스트
    print(case)			# 해주고 문자열을 출력













10814. 나이순 정렬


풀이


import sys		# sys함수로 빠르게 진행하자

num = int(sys.stdin.readline())		# 반복할 횟수 받기

answer = []			# 정렬하고 출력할 리스트
for i in range(num):
    answer.append(list(sys.stdin.readline().split()))		

answer.sort(key= lambda x : int(x[0]))		# 람다식을 이용해서 쉽게 기준을 잡고 정렬
		# 이거 기억해두기 앞으로 많이 써먹을수 있을듯
for k in range(num):
    print(answer[k][0],answer[k][1])	# 출력







15649. N과 M (1)


풀이

# 수열은 파이썬에 특정함수가있다.
# 굳이 for문을 쓰지않아도 구현이가능하지만
# for문 으로 구현한 코드도 같이 이해하자.

from itertools import permutations		# 수열 함수 사용

N,M = map(int,input().split())

P = permutations(range(1,N+1),M)		# 수열을 만들어줌 1,N+1 까지 범위에
for i in P:					# M 개의 수열
    print(' '.join(map(str,i)))			# str로 받아서 join 해줌




for문을 쓴 풀이


N, M = map(int,input().split())

vis = [False] * N       # 탐사 여부 탐사했으면 True

out = []    # 출력 내용

def su(dpth,N,M):
    if dpth == M : # 탈출조건
        print(' '.join(map(str,out)))
        return

    for i in range(len(vis)):   # 길이만큼 탐사
        if not vis[i]:  # False 이라면
            vis[i] =True    # 탐사 시작
            out.append(i+1) # 탐사내용
            su(dpth+1,N,M)  # 깊이 우선탐색
            vis[i] = False  # 탐사 완료
            out.pop()    #모든 탐사내용 제거
    

su(0,N,M)


# 배열을 이용 False 과 True 를 이용  
# 함수를 만들어서 탈출 조건 (출력조건)을 만들고
# 반복문을 하나만들어서 True , False 을 이용해서 하나하나씩 탐색
# 중간에 함수를 다시 삽입하므로써 계속해서 탐색
# 조건을 완료하면 다 False로 돌리고 탐사내용 제거 그리고 다시 탐사시작




15650. N과 M (2)


# not in 으로도 분류가 가능!!

# idx 를 이용해서 시간복잡도를 줄일수도있음
# ex for i in range(len(a) -1):
#	for j in range(i+1,len(a):
# 등등

풀이


# 조건이 생김 여기 식에서 중복을 제거해야함 set 으로 1 2 이나 2 1 같은 중복을 제거해야함

N, M = map(int,input().split())

vis = [False] * N       # 탐사 여부 탐사했으면 True

out = []    # 출력 내용



def su(dpth,idx,N,M):
    if dpth == M : # 탈출조건
        print(' '.join(map(str,out)))
        return
    for i in range(idx,N):   # 길이만큼 탐사
        if not vis[i]:  # False 이라면
            vis[i] =True    # 탐사 시작
            out.append(i+1) # 탐사내용
            su(dpth+1,i+1,N,M)  # 깊이 우선탐색
            vis[i] = False  # 탐사 완료
            out.pop()    #모든 탐사내용 제
    

su(0,0,N,M) # 블로그참고했음! https://wlstyql.tistory.com/58



# 즉 받아야할 정수 N,M을 받고 탐사할 배열을 만든다 [False]*N
# 그다음 출력을 담을 배열을 하나 만들고
# 함수를 하나 만든다 ( 탈출변수 , DPS 함수 , N , M)
# 그리고 탈출조건을 세우고 join 함수를 이용해 출력
# 그리고 반복문을 이용해서 탐사 코드를 작성한다.
# 본래 탐사 작성 코드는

if 탈출변수 == M:
	print(' '.join(map(str,out)))

for i in range(len(vis)):
	if not vis[i]:	# 즉 False이면
		vis[i] = True
		out.append(i+1)
		su(dpth +1 ,N,M)
		vis[i] = False
		out.pop() 

DPS >> 동적계획법 >> 다시 처음부터하는 시간낭비를 줄이기위해 중간 중간 저장하는 변수



15651. N과 M (3)


풀이



# 이제는 전부 출력가능
# 우리가 순차 대로 출력하기위해 False과 True를 썼는데
# 전부 반복적으로 111 등 출력이 가능하면  False True 을 사용할 필요가없다.
# 따라서 전부지워준다.

N, M = map(int,input().split())

#vis = [False] * N       # 탐사 여부 탐사했으면 True

out = []    # 출력 내용



def su(dpth,N,M):
    if dpth == M : # 탈출조건
        print(' '.join(map(str,out)))
        return
    for i in range(N):   # 길이만큼 탐사
        #if not vis[i]:  # False 이라면
            #vis[i] =True    # 탐사 시작
        out.append(i+1) # 탐사내용
        su(dpth+1,N,M)  # 깊이 우선탐색
            #vis[i] = False  # 탐사 완료
        out.pop()    #모든 탐사내용 제
    

su(0,N,M) 




# 위의 문제와 마찬가지로 정수를 받고 out 이라는 변수 리스트를 만들고
# 반복적으로 모두 출력이가능하므로 False True 를 사용할 필요가없으므로 제거해주고
# 그대로 N만큼 반복



15652. N 과 M (4)


풀이


N, M = map(int,input().split())

#vis = [False] * N       # 탐사 여부 탐사했으면 True

out = []    # 출력 내용



def su(dpth,idx,N,M):
    if dpth == M : # 탈출조건
        print(' '.join(map(str,out)))
        return

    for i in range(idx,N):   # 길이만큼 탐사
        out.append(i+1) # 탐사내용
        su(dpth+1,i,N,M)  # 깊이 우선탐색
        out.pop()    #모든 탐사내용 제
    

su(0,0,N,M) 


# 위와 똑같은 알고리즘에서 놀면된다. 즉 문제조건을 살펴보자

# 1.1부터 N까지 자연수 중에서 M개를 고른 수열
# 2.같은 수를 여러 번 골라도 된다.
# 3.고른 수열은 비내림차순이어야 한다.
# 4.길이가 K인 수열 A가 A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.

이므로 일단은 1.을 만족하기위해 N과 M을 받고
2.를 만족하기위해 원래 짜놓았던 탐색 알고리즘에서 False 과 True 를 없앤다. 
?>(같은위치를 탐색하지않기 위해서 해놓은것이 False , True )

출력함수는 미리 설정해놓은거 사용하고(join)

비내림차순은 오른쪽이 크거나 같아야한다. 따라서

(2) 에서 했던것 처럼 idx 를 넣어주고 돌리면된다.

즉

1. False True 를 없애면 중복이 되고
2. idx 즉 인덱스를 넣어주면 비내림차순이 성립된다 ( ex) 111 , 222, 333 이 가능




골드 문제

9663. N-Queen

풀이




















