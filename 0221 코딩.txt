



1. 멀쩡한 사각형



풀이

import math
def solution(w,h):
    return w*h - (w+h-math.gcd(w,h))


# 최대공약수로 풀았다. gcd라는 최대공약수를 구하는 함수를 사용하기위해 math를 사용했다
# 전체 사각형 에서 가운데로 가로질렀을때 제거해야할 부분 즉 최대공약수부분을 뺴준다.
# 그러므로 w*h 에서 w+h만큼 더하고 최대공약수를 뺴주고 나온 답으로 다시 전체에서 방금 구한
# 숫자를 빼면 답이나온다.

2. 괄호 변환


풀이	( 나중에 복습하면서 다시풀기 )


def s(p):
    if p =='':
        return ''
    else:
        cnt = 0
        for i, k in enumerate(p):
            if k==')':
                cnt -=1
            if k == '(':
                cnt +=1
            if cnt ==0:
                break
        return p[:i+1], p[i+1:]
    
def chk(u):
    cnt = 0
    for i in u:
        if i=='(':
            cnt +=1
        else:
            cnt -=1
            
        if cnt < 0:
            return False
    return True

def str(p):
    try:
        u,v = s(p)
    except:
        return ''
    answer =''
    if chk(u):
        answer +=u
        answer +=str(v)
        return answer
    else:
        answer +='('
        answer +=str(v)
        answer +=')'
        u = u[1:-1]
        for i in u:
            if i=='(':
                answer += ')'
            else:
                answer +='('
        return answer
            

def solution(p):
    answer = str(p)
    return answer
    



3. 더맵게


풀이


def solution(scoville, K):
    import heapq
    data = []
    
    for i in scoville:
        heapq.heappush(data, i)
    answer = 0
    
    while len(data) > 0:
        if data[0] >= K:
            return answer
        a = heapq.heappop(data)
        if data !=[]:
            b = heapq.heappop(data)
            heapq.heappush(data, a+(b*2))
        answer +=1
    return -1



# 일반 배열을 사용하면 시간초과가 발생하기떄문에 힙스택때 사용하는 heapq를 사용한다
# data라는 [] 공간을 만들어준다. 그리고 scovile만큼 반복문을 돌리고 heapq를 사용하여 data를
# 넣어준다. 그리고 몇번 섞었는지 확인하기위해서 answer이라는 변수를 설정해준다.
# 그리고 이제 data의 길이가 0이상일떄 반복문을 계속돌리고 만약에 최솟값이 k보다 같거나 크면
# 그대로 중지해서 answer값을 반환한다. 그게 아니라면 a라는 변수를 만들고 거기다가 남은 값들을
# 넣어준다. 그리고 data가 공백이 아니라면 다시 b라는 변수를 만들고 남은 데이터를 넣어준다.
# 즉 a라는 최솟값을 뺴내었고 그 두번째의 최솟값이 b인것이다. 그래서 문제 설명대로 
# heapq.heappush(data, a + (b*2))를 해준다. 그리고 마지막에 카운터로써 answer 을 1씩 증감한다.
# 그외에 이제 남은경우는 []인 경우인데 그경우에는 -1을 반환한다.


