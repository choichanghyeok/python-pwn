리눅스 4강
(   )

리눅스 5강
(   )


3시부터


2. 큰수만들기 ( 다시풀기 복습할때 천천히 ) 


풀이

def solution(number, k):
    Le = len(number)
    
    if Le > k:
        m = 0
        for cnt in range(k):
            for idx in range(m, Le-1):
                if number[idx]< number[idx+1]:
                    number = number[:idx] + number[idx+1:]
                    Le -=1
                    if idx > 0:
                        m = idx -1
                    break
            else:
                number = number[:Le-k+cnt]
                break
        return "".join([str(i) for i in number])
    else:
        return "0"

# 넘버 길이만큼 하기떄문에 len으로 길이를 구한다. Le가 k가 자리수이기떄문에 클떄 m을 0으로 잡고
# k의 범위만큼 반복문을 돌린다. 이제 숫자를 만들 반복문을 돌리는데 idx를 m부터 number자릿수 미만
# 이기떄문에 number-1까지 돌려준다. 그리고 만약에 number[idx]가 number[idx+1] 보다 작다면
# number은 그 숫자 끝에서부터 숫자 앞까지 즉 1~10이라고한다면 그리고 idx가 4라고 한다면
# number[:idx]는 1234 이고 number[idx+1:] 678910 이다. 그리고 길이를 1감소시켜준다 만약 idx가 
# 0이 아니라면 m은 idx에서 -1을 뺸값이다. 또 0이라면 number은 길이에서 k를 빼주고 cnt를 더해준 값이다.
# 마지막으로 "".join()으로 정리해주고 number을 for문으로 돌린것을 다str(i)해주고 리턴해주면된다.
# 나머지 다른경우라면 "0" 문자열 0을 리턴해준다.






3. 조이스틱


풀이

def solution(name):
    answer = 0
    name=list(name)
    base=["A"]*len(name)
    idx=0
    while(True):
        r=1
        l=1
        if name[idx]!="A":
            if ord(name[idx])-ord("A")>13:
                answer+=26-(ord(name[idx])-ord("A"))
            else:
                answer+=ord(name[idx])-ord("A")
            name[idx]="A"
        if name ==base:
            break
        else:
            for i in range(1,len(name)):
                if name[idx+i]=="A":
                    r+=1
                else:
                    break
                if name[idx-i]=="A":
                    l+=1
                else:
                    break
            if r>l:
                answer+=l
                idx-=l
            else:
                answer+=r
                idx+=r
    return answer





# 결과값을 구하기위해 answer이란 변수를 만들고 주어진 name을 리스트화 시킨다. 그리고 A부터 시작한다했으니
# "A" 와 name길이와 곱한것을 베이스로 두고 구한다. 몇번 이동했는지 구하기위해 idx라는 변수를 만들어놓는다.
# 그리고 while문을 돌린다.  그리고 오른쪽이동과 왼쪽이동 변수를 만든다. 그리고 name 문자열에서 A가아닌 문자열이 나오면
# 그 문자열로 맞춰야하기떄문에 탐욕법을 쓴다 탐욕법은 최선의 경우의 수를 내는것을 말한다. 즉 A-Z 까지 반을 쪼개면 25이므로
# ord(name[idx]) -  ord("A") 가 13보다 크다면 상위 숫자 이기떄문에 26- ord(name[idx]) -  ord("A") 만큼 해주면 횟수가된다.
# 다른경우는 절반이 넘어가는 큰수가 아니기떄문에 그대로 ord(name[idx]) -  ord("A") 하면 된다. 이것들을 answer에 더해주면 된다.
# 그리고 다시 name[idx] = "A"로 설정한다. 만약 주어진 name 문자열과 우리가 맞춘 문자열이 동일하면 종료한다.
# 여기까지가 상 하 조이스틱을 만들었고 이제 좌우를 만들면 되는데 좌우는 1부터 name 길이만큼 반복문을 돌린다.
# 그리고 만약 name[idx+i]이 "A"라면 오른쪽에 1을 증가시키고 반대라면 왼쪽에 1을 증가시킨다. 이것도아니라면 종료한다.
# 오른쪽이 왼쪽보다 클경우 answer에 왼쪽을 모두 더하고 idx는 뺀다 반대로 왼쪽이 클경우 오른쪽을 모두 더하고
# idx는 뺸다. 그리고 answer을 리턴한다.




1. 가장 큰수


풀이


def solution(numbers):
    numbers = list(map(str,numbers))
    numbers.sort(key = lambda x: x*3, reverse=True)	(x*3부분 나중에 질문)
    return str(int("".join(numbers)))


# numbers 를 map 함수를 이용해서 str 즉 문자열로 바꿔준다. 그리고 sort로 정렬 해주면서 
# 람다식을 이용한다. numbers을 정렬하고 x에다가 *3을 한다 그리고 역순 배열을 한다.
# 마지막으로 정수형태로 "".join()함수로 붙여주고 다시 str로 문자열 상태로만들어서 
# 반환한다.

풀이2


def solution(numbers):
    numbers = list(map(str,numbers))
    answer = "".join(sorted(numbers , key = lambda x: (x[0],x[1%len(x)],x[2%len(x)],x[3%len(x)]), reverse=True))
    return answer if int(answer) != 0 else "0"

# 이건 위에와 똑같이 map화시키고 람다식을 활용한다. 자릿수가 4자리이므로 x[0] ~ x[3%len(x)]까지
# 구하고 역순으로 뒤집는다 그리고 반환하는데 혹시 라도 0이나오면 문자열"0"을 반환한다.


