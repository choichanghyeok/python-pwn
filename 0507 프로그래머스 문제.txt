1. 예상대진표


def solution(n,a,b):
    
    cnt = 0  # 경기수
    
    while a !=b:
        a = (a+1) //2		# a와 b가 서로 붙기전까지 계속 이긴다고 하므로
        b = (b+1) //2		# 가정을하면 a와 b가 결승에서 만날때 까지 계속 이겨야하므로 
        cnt +=1		# a와 b가 같을떄까지 반복문을 돌려주고 cnt 1씩 증가시킨다.
        
    return cnt





2. [1차] 캐시


LRU 알고리즘((Least Recently Used)

##데이터를 교체해야하는 데 여기서 어떤 데이터를 교체할 것인가##

>>가장 최근에 사용되지 않은 것 즉, 가장 오래전에 사용한 것을 제거하는 알고리즘


@@@ 다시 풀어봐야됨 ( 이해 x) @@@


def solution(cacheSize, cities):
    time = 0 # 실행시간
    
    cache = []  # 캐시에 도시들을 보낼 배열공간
    
    cities = [city.lower() for city in cities]  
    # 대소문자 구분을 안한다하였으니 소문자로 통일
    
    if cacheSize !=0:
        for city in cities:
            if city in cache:
                cache.pop(cache.index(city))        
                # 만약 cache 배열안에 넣고자하는 해당 도시가 있다면 제거하고 도시를 넣는다.
                cache.append(city)
                time +=1    # 정상적인 진행이므로 time 1증가
                
            else:
                if len(cache) < cacheSize:
                    cache.append(city)
                    time += 5       # cache 길이가 캐시 사이즈보다 작다면 해당 도시들을 cache 배열에 길이가 커질떄가지 넣고 miss 이므로 5씩 증가시킨다
                    
                else:
                    cache.pop(0)
                    cache.append(city)
                    time +=5        # 나머지의 경우
                    
    else:
        time += len(cities)*5
    return time


