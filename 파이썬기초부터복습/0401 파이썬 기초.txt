1. 41강 ~42강

구문 오류와 예외 공부

# 구문 오류
>> 코드에 문제가 있어서 실행이 안됨.

# 예외(런타임 오류)
>> 코드 자체 문법적인 오류가 생김
> 즉 실행과 관련된 문제, 실행은 되나 죽는다.(실행이 꺼진다)

즉 이런 오류들을 막기위해 "예외처리" 를 해주어야한다.

즉 try except구문을 사용

ex)

**************************************************************
try:
	예외가 발생할 수 있는 가능성이 있는 코드
except:
	예외가 발생했을 때 실행할 코드

**************************************************************

print(float(input("> 숫자를 입력해주세요: ")) **2)  	<< 이 코드를 예외처리를 해보자


while True:

	try: 
		print(float(input("> 숫자를 입력해주세요: ")) **2)
		break
	except:
		print("숫자를 입력해주세요.")



>> 구문오류와 예외의 차이

구문오류는 실행전에 발생하고 예외는 실행후에 발생한다.

구문오류는 문법적인 문제를 해결해서 해결할수있고 예외는 예외처리를 해서 해결할수있다.


******************************************

TypeError	예외
ValueError	예외
SyntaxError(문법오류)	구문
IndexError	예외

******************************************

index() 함수는 왼쪽을 제일먼저 찾고 리스트내부에 코드가 없다면 ValueError 에러가 일어남

if 구문이나 try 구문을 사용하면 예외처리가 가능  ( 보통은 try 구문을 사용)




2. 43강

finally 구문에 대해서 공부

사용법은

try:				>> 예외가 발생할수 있는 코드
	print()
execpt:				>> 예외가 발생했을 경우 실핼할 코드
	print()
finally:				>> 무조건적으로 실행하는 코드
	print()

형태로 사용한다.


finally 구문을 사용하는 이유??

>> 함수 내부에서 return 키워드나 반복문 내부에서 break 키워드를 사용할때 의미를 갖는다.

finally 구문을 사용하면 finally 구문 까지 실행되고 그 아래의 코드들은 실행이 되지않는다. 그리고 finally 구문은 무조건적으로 실행됨.





3. 44강


예외 처리 추가내용

ex)

try:
	print("")
except	ValueError as exception:
	print("값에 문제가 있습니다.")
except	IndexError as exception:
	print("값에 문제가 있습니다.")
except	Exception(무엇을 넣어야할지모를때 대표적인 클래스) as 변수로 사용할 이름(e, exception):
	if type(exception) == ValueError:
		print("값에 문제가 있습니다.")

이 형태로 여러 except를 사용할수 있고 아니면 except 하나에 if문을 사용해도 된다.



# raise 키워드		>> 예외를 강제적으로 발생시킨다.

ex)

raise Exception("안녕하세요")		
raise ValueError("안녕하세요")
raise IndexError("안녕하세요")


**********************************************************************************************************************************************************************

파이썬에서는 raise 키워드가 강제로 발생시키고 다른 c++이나 다른 객체코드에서는 thorw 를 쓴다.

tensorflow 프레임 워크	>> 적어도 반드시 포워드셀을 지정해야한다.		(포워드셀을 지정하지않으면 실행이 죽어버린다.) ## 참고!!

**********************************************************************************************************************************************************************



4. 45강 ~ 46강

클래스 도입

객체(object)
>> 속설 + 행위

ex) 
사람 
>> 이름,키,나이,생년월일 등
행위
>> 달린다,걷는다 등

# 객체지향 프로그래밍 언어

>> 동사 + 목적어 : 명령어
ex) print("xxxx")
출력(학생)
평균(학생)
총합(학생)

(클래스 기반)
주어 + 동사 + 목적어 : 주어가 행위를 한다. >> 이것이 객체지향프로그래밍언어 형태
학생.출력()
학생.평균()
학생.총합()


*********************************

클래스 기본 구성요소

1. 속성 정의하기

2. class 내부에 함수를 만들때 첫번째 매개변수는 무조건 자기자신(self)

*********************************


기본 클래스 선언하는 법

ex)

class Student:
	def __init__(self):
		print("객체가 생성되었습니다.")		>> 생성자
	def __del__(self):
		print("객체가 소멸되었습니다.")		>> 소멸자

student = Student()

**************************************

# 클래스(틀)
# 객체(실체화 된 것)
# "인스턴스" == 실체화 한 객체

**************************************


>>클래스를 사용해서 속성과 행위를 한번에 관리하는 함

ex) 속성

class Student:
	def __init__(self, 이름, 나이):
		print("객체가 생성되었습니다.")		>> 생성자
		self.이름 = 이름
		self.나이 = 나이


	def __del__(self):
		print("객체가 소멸되었습니다.")		>> 소멸자

student = Student("ㅇㅂㅇ", 3)

print(student.이름, student.나이)

-출력-



ex) 행위

class Student:
	def __init__(self, 이름, 나이):
		print("객체가 생성되었습니다.")		>> 생성자
		self.이름 = 이름
		self.나이 = 나이


	def __del__(self):
		print("객체가 소멸되었습니다.")		>> 소멸자

	def 출력(self):
		print(self.이름, self.나이)

student = Student("ㅇㅂㅇ", 3)

student.출력()

위의 속성 코드와 똑같이 출력됨





5. 47강


## 특이한 이름의 함수

__ 의 함수는 >> 자동적으로 호출되는 함수

ex)

def __str__(self):
	retrun "문자열"


****************************************************

## 비교연산자의 영어표현

>> eq(equal 같다)
>> ne(not equal 다르다)
>> gt(greater than 크다)
>> ge(greater than or equal 크거나 같다)
>> lt(less than 작다)
>> le(less than or equal 작거나 같다)

****************************************************

ex)

def __eq__(self,other):	>> other을 넣는이유는 자신과 다른것을 비교해야하기 때문이다.
	print("eq() 함수")
	return self.나이 == other.나이  	>> 이렇게 같은지 아닌지 이러한식으로 return을 해주어야한다.	(이렇게 해주면 True 나 False 로 출력된다.)
def __ne__(self,other):
	print("ne() 함수")


이러한 형태로 쓴다.


