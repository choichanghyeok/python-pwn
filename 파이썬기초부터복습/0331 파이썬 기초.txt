1. 36강

리스트 평탄화 (flatten) >> 중첩된 리스트가 존재할때 중첩을 모두 제거하고 풀어서 1차원 리스트로 만드는것을 의미한다.

type 을 사용해서 이 입력된것이 int 인지 str 인지 list인지 판별이 가능함.

************************************************************************************

고정상수라면 변수를 만드는것이 좋다.

함수를 만들어서 사용하면 코드 유지보수에 유용하다.

************************************************************************************


2. 37강 

튜플 


튜플이 리스트와 다른점은 대괄호[ ]가아니라 소괄호( )를 사용해서 만든다는 점이고 튜플은 값을 변경할수없다.

 ex)

[a,b] = [10,20]
[c,d] = (30,40)

print(a,b,c,d) 

라면 10 20 30 40 이 출력되는데

튜플은 한번에 여러개를 할당할떄 쓰게된다. 대표적으로 '스왑' 이있다.

a ,b = b, a(튜플) 라는 코드를 입력하면 두개의 값이 바뀌어서 출력된다.

************************************************************************************
divmod(x//y,x%y) 값을 출력하는 함수	>> 몫과 나머지

튜플은 ()를 생략이가능하다.

************************************************************************************

여러개의값을 리턴할때에는 튜플을 사용해준다.

요소가 한개가 있는 튜플을 만들고싶다면 뒤에 쉼표를 찍어주면된다. >> 즉 구분을 하기위해서 찍어주는것이다.

ex) print((273,)) 

형태로 입력해 주면 된다.


딕셔너리의 키로는  숫자,문자열,불,리스트,튜플 까지 딕셔너리의 키로 사용가능하다.





3. 38강


콜백함수와 람다, map() , filter() 함수를 공부

*****************************************************************************************************************************


콜백함수 >> 내가함수를 호출하는것이아니라 다른 어떤함수에서 호출되는 함수가 콜백함수이다.

람다 >> 사용법 (lambda x : x(출력물,x))   자동으로 뒤에 리턴키워드가 붙어있음.

람다식에서 map() , 과 filter() 함수를 사용

filter() >> list에서 필터역할	(이제 사용할식 , 변수)

map() >> list에서 무슨 인자를 받을지 결정   (이제 사용할식 , 변수)


******************************************************************************************************************************


ex) 

def 짝수만(num):
	return num % 2 ==0

a = list(range(100))
#print(a) >> 0~99

b = filter(짝수만 , a)
print(list(b)) >> 0~99까지 짝수만 출력



이 코드를 람다식으로 바꾼다면 b = filter(lambda num: num%2==0 , a)

map함수는

def 제곱(n):
	return n*n

a = list(range(100))
print(list(map(제곱,a))


람다로 바꾼다면 print(list(map(lambda n : n*n ,a)))

또 i*i for i in a 를 사용해서 출력도 가능하다.

print() 함수를 사용해서 출력을 하면 완전히 새로운 리스트가 메모리위에 복제되어서 만들어진다 즉 용량을 차지함.

map()함수를 사용한다면 이 객체는 메모리상의 용량을 크게 차지하지않아서 메모리공간이 절약됨.


************************************************************************************************************************************************************************

map() 과 filter() 함수 등은 제너레이터 함수라서 내부의 데이터가 실제로 메모리에 용량을 차지하는것들이 아니다.

-- 리스트 내포를 사용하는것을 추천 --

************************************************************************************************************************************************************************




4. 39강

파일처리에 대해서 공부

두가지 속성

1. 어떠한 대상을 처리할것인가.

>> 텍스트파일 >> 텍스트에디터로 열수있으면 텍스트파일이고

>> 바이너리파일 >> 텍스트에디터로 열수없다면 바이너리 파일이다.	(이미지,동영상,워드,엑셀,PDF 등)  즉 비쥬얼코드나 스튜디오로 읽을수없다면 바이너리파일이다.


2. 그 대상을 어떻게 다룰것인가.

>> 쓰기

	>> 완전히 새로쓰는것과(write) >> w	

	>> 있는 파일 뒤에 추가하는것(append) >> a

>> 읽기(read) >> r


************************************************************************************************************************************************************************

open()  이라는 함수를 사용하면 file이라는 객체가 나오게되고 file이라는 객체는 다 사용한후에 file.close() 라는 코드를 입력해 파일을 닫아야한다.

ex)

file = open("test.txt", "w")	>> 파일을 만들고 적음
filr.write("안녕하세요")
file.close()

file = open("test.txt", "a")	>> 파일의 내용을 추가함
filr.write("안녕하세요")
file.close()

file = open("test.txt", "r")	>> 파일의 내용을 읽음
print(file.read())
file.close()


또 자주 open 을 사용하기 귀찮다면
>> with 파일 오픈 as file: 이라는 코드로 호출을 하게되면 		>>open 과 close 가 with 구문내에서 자동적으로 close() 구문이 실행됨.

with file = open("test.txt", "a") as file:
	file.write("안녕하세요") 

이 두줄의 코드와 위에 세줄의 코드는 같은 코드이다.


save() >> 저장 관렴 함수(??)


************************************************************************************************************************************************************************




5. 40강

제너레이터에 대해서 공부


제너레이터 >> 이터레이터를 직접만들때 사용하는 구문 이고 함수 내부에 yield(양보하다) 라는 키워드가 포함되면서 해당 함수는 제너레이터가 된다.

ex)

def 함수():
	print("출력A")
	print("출력B")
	yield 100			>> 가 함수내부에 삽입되는 순간 이함수는 제너레이터가 되어버림.


제너레이터 = 함수()

#next(제너레이터)		>> next()를 써야 제너레이터 출력이가능

값 = next(제너레이터)
print(값)

>> 숫자 라면 이러한 형태로 출력하면 된다.

yield 를 만나면 양보를 해서 yield에서 멈추게 된다. 즉 중간에 멈출수있게되어서 멈추고 실행하고 멈추고 실행하고가 가능하게 된다.

제너레이터 = 함수() 라면

****************************************************************************************************************************************************************************************

for i in 제너레이터:		>> 그리고 제너레이터는 일회용 함수 (reversed도 마찬가지) 이다.	>> 즉 reversed나 제너레이터를 사용하면 메모리를 절약할수 있음.
	print(i)	>> 전부실행됨

****************************************************************************************************************************************************************************************





