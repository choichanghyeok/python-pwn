1. 폰켓몬(나중에복습)

풀이

def solution(nums):
    answer = 1
    
    mx = int(len(nums)/2)
    nums.sort()
    
    sta = nums[0]
    
    for i in range(len(nums)):
        if nums[i] > sta:	# nums[i]길이가 클때 
            sta = nums[i]
            answer += 1
        if mx < answer: 	# nums길이가 짧을때??
            return mx
    return answer

# 기본적으로 최소 한개이상의 경우가 발견되기떄문에 answer은 1을 가지고 시작한다. 
# mx는 최대값으로 nums의 길이를 구해주고 /2 등분을 해준다 그리고 정수형으로 받을수있게 int형으로 바꾸어준다.
# 그리고 nums의 값을 sort로 정렬하고 sta라는 nums의 첫번쨰 값을 만들어준다. 바로 nums[0]의값
# 그리고 nums길이만큼 반복문을 돌려주고 만약에 반복문을 돌리면서 nums[i]의 값이 sta의 값보다 크다면 즉 nums[0]보다 클때
# sta의 nums[0]를 nums[i]로 바꾸어주고 answer이라는 카운트에 1을 증가시킨다.
# 만약에 nums 길이가 answer길이보다 작아진다면 그대로 mx를 반환하고 이경우들이 아니라면 answer을 리턴한다.



2. 가장큰 정사각형(나중에복습)

동적계획법(DP  다이나믹 프로그래밍)을 사용해서 풀어야하는 문제

풀이


def solution(board):
    # check whether board is consist of only zeros
    _s = 0
    for i in range(len(board)):
        _s += sum(board[i][:])
    if _s == 0:
        return 0
    
    _s = 0  # initialize _s to 0
    
    table = [[x for x in sub] for sub in board]
    for x in range(1,len(table)):
        for y in range(1, len(table[x])):
            if table[x][y] == 0:
                continue
            else:
                _min = min([table[x][y-1], table[x-1][y], table[x-1][y-1]])
                table[x][y] = _min + 1
                if _s < table[x][y]:
                    _s = table[x][y]
                    
    # if board looks like identity matrix _s would be 0, but max square would be 1.
    if _s == 0:
        return 1
    else:
        return _s ** 2


다른풀이 

def solution(board):
    
    width = len(board[0]) # 가로  배열길이로는 구할수 없기때문에 초기값
    height = len(board) # 세로 배열 
    #print()
    for x in range(1, height):
        for y in range(1,width):
            if board[x][y] == 1:
                board[x][y] = min(board[x-1][y-1], min(board[x-1][y],board[x][y-1])) +1 
    return max([item for row in board for item in row])**2


>> 가로와 세로의 길이를 구해준다 즉 세로는 배열의 길이이고 가로는 배열의 첫번쨰[0]의 길이이다.
	따라서  x의 높이만큼 반복문을 그리고 y의 가로만큼의 반복문으로 이중 포문을 돌린다.
	그러다가 만약에 1이라는 숫자가 나온다면 자기가 현재있는 위치를 저장해야했기에 DP를 이용한다
	그래서 board[x][y]에 최소의 점을 찾아준다. 즉 min(board[x-1][y-1], min(board[x-1][y],board[x][y-1])) 처럼 세점을 찾아주고 만약 
	1 1  이라면 오른쪽 이나 아래 대각선에도 1이있는지 확인하기위해 세점을 찾아주고 또 다른 점이 있는지 확인하기위해 최소점을 찾아준다.
	1 1
	그리고 max([k for row in board for k in row]) 의 구한 정사각형의 길이를 구해서  **2 해준다

3. 땅따먹기(나중에복습)

풀이


def solution(land):
    
    L = len(land)
    
    for i in range(L-1):
        land[i+1][0] = max(land[i][1],land[i][2],land[i][3]) + land[i+1][0]
        land[i+1][1] = max(land[i][0],land[i][2],land[i][3]) + land[i+1][1]
        land[i+1][2] = max(land[i][0],land[i][1],land[i][3]) + land[i+1][2]
        land[i+1][3] = max(land[i][0],land[i][1],land[i][2]) + land[i+1][3]
        
    return max(land[-1])

>> land의 길이를 구하고 행하나하나 씩 비교한다 즉 어차피 첫행의 최대값부터 시작한다.
	따라서 L-1 을 해주고 land[i+1][j]부터 시작한다. 자기 열은 다시 지날수없으니 자기열을 제외한 나머지의 최댓값을 구하고 다음으로
	이전행을 더해준다. 이러한식으로 최댓값을 구하고 land[-1] 을해준다.