1.7강
# 리틀 엔디안, 빅엔디안


20 > 0010100



#낮은주소부터 큰주소 방향으로 주소를 사용한다.

# 낮은 자리수부터 저장한다.

저장할떄는 앞에서부터 !!

읽는방법은 저장한 방법의 역순대로 읽으면 된다.


@리틀 엔디안
낮은 자리수가 먼저 저장되기떄문에 3456 주소가 들어가면 56 34 이렇게 읽힌다.

@빅 엔디안

높은 자리수가 먼저 저장되기 떄문에 3456 주소가 들어오면 3456 그대로 읽힌다.


빅엔디안을 리틀엔디안으로 읽는다면

빅엔디안의 높은자리가 낮은자리가 되므로 뒤로간서 읽힌다.

따라서 3456 이라면 6A2C 로 읽힌다.(즉 엉망으로 읽힌다. 바이트순서가 거꾸로되어있기때문)


읽고 쓰기 방식이 보존된다면 데이터는 잘 보존된다.



402004 에서는 78이라는 것이 순서가 거꾸로 저장되어있음 낮은자리 비트가 먼저나오도록

가장 낮은 두바이트
78 > 00011110

56

장점

리틀엔디안은 cpu 최적화에 좋아서 기능에 유리

빅엔디안은 우리가 노트에쓰는 2진수 자리수 대로 저장하기 떄문에 읽기에 용이하다(사람이)


★★★★★★결론★★★★★★★★★★★★★★★★★★★★★★


데이터는 낮은주소에서 높은주소로 그비트순서대로 읽거나 사용하고

리틀엔디안 낮은주소 부터 저장하고 빅엔디안은 높은주소부터 저장한다.

읽을 때는 낮은주소에서 높은주소 비트 순서대로 읽고

리틀엔디안은 먼저읽은 비트를 낮은주소부터 채워 넣고 

빅엔디안은 먼저읽은 주소를 높은 주소부터 채워넣는다.

( 점심먹고 다시한번 리틀엔디안과 빅엔디안 보기 )


EX) 00010100

리틀엔디안

00101000

빅엔디안

00010100

2바이트 56

0011 0100 0101 0110
   3    4     5      6

낮은자리 리틀엔디안

0110 1010 0010 1100

높은자리 빅엔디안

0011 0100 0101 0110

읽는 방식 !!!!

저장하는 방식의 역순
메모리는항상 낮은곳에서 높은곳

빅엔디안 (메모리에있는것을 레지스터에 옮긴다)
높은자리부터 저장

@ 0011 0100 0101 0110

즉 읽을떄 이대로 읽음

리틀엔디안

낮은자리부터저장

@ 0110 1010 0010 1100

즉 읽을떄 이대로 읽음

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★


2. 8~9강

@ 점프 jmp


실행의 흐름을 뛴다.!!  그것이 jmp!	(C언어로는 무한반복문)


Ram에서 기계어 데이터를 (특정주소에서) 읽어온다. 

읽어온 주소만큼 주소값을 증가시킨다. 

읽어온 기계어를 실행함 

mov eax,0

eip , 401005   >> eip는 범용레지스터가 아님   ( eip에는 mov 를 사용할수없다) 그래서 jmp를 사용해서
흐름을 바꾸는것이 존재함

short > 이동할 위치가 가까우면 jmp short 사용

ex) JMP SHORT 00401005


1 바이트 -127 ~ +127 안의 범위를 short 이고 넘는다면 long를 쓴다.


dword 와 word 로 사이즈를 정해주어서 주소를 넣을수있음


3. 10 .

##inc, dec

inc 증가 , dec 감소	( 1씩 증가 1씩 감소 )


ex)

mov eax,0
mov ebx,0

inc eax
inc ebx
inc ecx
inc edx

inc ax
inc al
inc ah

inc cx
inc cl
inc ch

inc dword ptr ds:[402000]

inc word ptr ds:[402000]

inc byte ptr ds:[402000]

dec eax

dec ax

dec dword ptr ds:[402000]


