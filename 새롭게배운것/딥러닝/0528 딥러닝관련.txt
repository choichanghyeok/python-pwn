1. 6~8강 

##Numpy

라이브러리 사용법

import numpy , import numpy as np 

from numpy import exp
> 장점은 해당 이름을 쓰지않고 바로쓸수있음

from numpy import *
> 필요한 라이브러리에 모든 API를 사용
> 이름을 사용하지않고 필요한 API를 직접 사용할수있음

numpy > 머신러닝 코드 개발할 경우 자주사용되는 벡터, 행렬 등을 표현하고 연산할떄 반드시 필요한 라이브러리

numpy vs list

>> 머신러닝에서 숫자,사람 동물 등 인식을 하기위해서는 이미지 데이터를 행렬로 변환하는 것이 중요함

>> 행렬을 나타내기 위해서는 리스트를 사용할수 있지만 행렬 연산이 직관적이지 않고 오류 가능성이 높기 때문에 행렬 연산을 위해서는
numpy사용이 필수이다.

벡터생성방법
> np.array[[]] 형태
행렬 생성
> np.arry[ [...],[...] ]

형변환은 reshape() 함수를 사용하여 바꾸어준다.




행렬곱 > A행렬과 B행렬의 행렬 곱 (dot product)는 np.dot(A,B) 나타내며, 행렬 A 의 열 벡터와 B행렬의 행 벡터가 같아야함 만약 같지않다면
reshape 또는 전치행렬 등을 사용하여 형변환을 한후 행렬 곱을 실행해야함.

ex)
	1	2	3			-1	-2
A =  	4	5	6		B = 	-3	-4
						-5	-6
형상:	            2x3				       3x2


이라면 형상은 2x3 , 3x2 이므로 앞의 행렬의 열과 뒷행렬의 행이 같으므로 곱할수있음


@@@@@@@@@@@@@@@@@@@@@


코드는
A = np.array([ [1,2,3], [4,5,6] ])
B = np.array([ [-1, -2], [-3, -4], [-5, -6] ])

C = np.dot(A,B)

print("A.shape ==", A.shape, " B.shape ==", B.shape)



@@@@@@@@@@@@@@@@@@@@@


즉 행렬 연산은

1. 사칙연산의 한계를 벗어나게함
2. 행렬곱 조건을 만족하는 다양한 크기의 행렬을 연속으로 만듦
3. 행렬 곱을 연속으로 계산하면서 다양한 결과값 만듦
4. 따라서 머신러닝과 이미지 프로세싱 분야에 자주 사용됨

ex)

입력 행렬 형상이 64 X 64 라면  결과 행렬 형상이 64 X 10 이라면 중간에 dot product를 만족시키는 어떤 형상의 행렬이라도 가질수있음

행렬 곱을 사용하지 않고 산술연산만 가능하다면 입력행렬의 64  X 64 크기를 가지는 특성값만을 사용해야하기 때문에

다양한 특성을 갖는 필터 개발이 불가능해짐.


	입력값			특성 값 행렬		결과값
      				
       (64 X 64) X|(64 X 256) X (256 X 512) X (512 X 64) X (64 X 10)| = (64 X 10)



라이브러리 >> 행렬의 사칙연산은 기본적으로 두개의 행렬 크기가 같은 경우에만 수행할수있음. 다만 numpy 에서는 크기가 다른 두 행렬간에도 사칙연산을
할 수 있는데 이를 브로드캐스트 라고 한다.

>> 차원이 작은 쪽이 큰쪽의 행 단위로 반복적으로 크기를 맞춘후에 계산

ex)
	1	2
A =	3	4		B = 5


	1	2
A + B =	3	4	+	5


  	 1	2		5	5		6	7
=			+			=
   	 3	4		5	5		8	9

				브로드캐스트



@@@@@@@@@@
코드

A = np.array([ [1,2], [3,4] ])
b = 5

print(A+b)

@@@@@@@@@@

	1	2
C = 	3	4	B = (4	5)

	1	2					1	2		4	5
C + D = 			+	(4	5)	=			+			
	3	4					3	4		4	5

										브로드캐스트

	5	7	
=	
	7	9	



@@@@@@@@@@
코드

C = np.array([ [1,2], [3,4] ])
D = np.array([ [4,5]])

print(C+D)

@@@@@@@@@@	


@ 전치 행렬 !!

전치행렬 >> 어떤 행렬의 전치행렬은 원본 행렬의 열은 행으로, 행은 열로 바꾼것으로서, 원본 행렬을 A라고 하면 전치행렬은 A**T로 나타냄

즉 1행은 1열로 2행은 2열로 3행은 3열로 바꿈

ex)

1	2		이라면				1	3	5
3	4		전치행렬화 시키면
5	6						2	4	6

으로 변환 시킬수 있다.

@@@@@@@@@@@@@@@@@@@@@

코드


A = np.array([ [1,2], [3,4], [5,6] ])
B = A.T

C = np.dot(A,B)

print("A.shape ==", A.shape, " B.shape ==", B.shape)
print(A)
print(B)



주의할 예시

기존 원본벡터는 계속 벡터로 남아있음.		전치행렬 만드는법 C.T

벡터는 열과 행렬을 구분하지않기떄문에 전치행렬을 하더라도 열과 행렬을 구분할수 없기 때문

그래서 벡터를 전치행렬화 시키고 싶다면 reshape() 메소드를 활용하여 바꿔 줄수 있다.

즉 ex) C.reshape(1,5) 라면 1X5 행렬이 된다. 따라서 전치행렬이 된다면 5X1이 된다.

@@@@@@@@@@@@@@@@@@@@@@@

행렬 원소 접근 >> 행렬 원소를 명시적으로 접근 하기 위해 리스트에서처럼 인덱싱, 슬라이싱 모두 사용가능함

ex ) A = np.array([ 10,20,30,40,50,60 ]).reshape(3,2)

print("A.shape==",A.shape)
print(A)

A.shape == (3,2)
A = [10	20]
      [30	40]
      [50	60]


즉 

A[0,0] 과 A[0][0] 과 같다.

   행     열
A[0:-1 , 1:2] 라면 0행의 -1열 값 과 1행의 2열 값이므로

[ [20] [40] ]


A[ : , 0] 라면 모든 행중에서 0 의 열 즉 첫번쨰 열의 모든데이터를 가져오라는 뜻  >> 10 30 50

A[ : , : ] 라면 모든 행중에 모든행과 열을 가져오라는 뜻이므로 > 행렬 A를 그대로 반환해주면된다.


##행렬의 iterator

>> 명시적 인덱싱 / 슬라이싱 이외에, 행렬 모든 원소를 access 하는 경우에는 iterator 사용가능

numpy iterator는 c++ ,java iterator 처럼 next() 메서드를 통해 데이터 값을 처음부터 끝까지 순차적으로 읽어 들이는 방법을 제공


iterator 사용하면 특정 값을 순서적으로 획득할수있는 방법을 사용가능

(즉 iterator 이용해서 편미분을 작성가능)

> (iterator 개념 , 행단위로 데이터를 접근 처음부터 마지막까지 데이터를 가져올수있음)

it = np.nditer(A, flags=['multi_index'], op_flags=['readwrite']) 를 사용하면 (처음 , 마지막) 데이터를 가져올수있음



@@ concatenate

>> 행 또는 열을 추가하기위한 함수이다.

머신러닝의 회귀 코드 구현시 가중치와 바이어스를 별도로 구분하지 않고 하나의 해열로 취급하기 위한 프로그래밍 구현 기술

ex) 

B = np.concatenate((A,row_add), axis = 0)


axis x y 축을 기준으로하는 변수이다 즉 0은 열(세로) 기준  1행(가로) 기준 을 뜻한다.

또 C =np.concatenate((A,column_add), axis = 1)




@@ useful function

seperator 로 구분된 파일에서 데이터를 읽기 위한것이다.

콤마(,)로 분리된 데이터 파일을 read 하기위해서 np.loadtxt("파일이름", seperator=',') 호출한다.

리턴 값은 행렬이기 때문에 인덱싱 또는 슬라이싱을 이용하여 데이터를 분리할 필요가 있다.

>> 머신러닝 코드에서 입력데이터와 정답데이터를 분리하는 프로그래밍 기법

ex)


loaded_data = np.loadtxt('./data-01.csv', delimiter=',' , dtype=np.float32)

		       열
x_data = loaded_data[ : , 0:-1]			# 즉 모든 행의 3열까지의 데이터가 저장됨  0:-1이 -1을 제외한 나머지이기 떄문임

t_data = loaded_data[ : , [-1]]			# 은 -1즉 4열의 모든 데이터를 가지고 있다.

print("x_data.ndim = ", x_data.ndim, "x_data.shape =",x_data.shape)
print("t_data.ndim = ", t_data.ndim, "t_data.shape =",t_data.shape)



1. numpy.random.rand() 
> 랜덤함수를 사용 랜덤으로 값을 리턴

2. numpy.sum() , numpy.exp(), numpy.log()
	합  	지수	   로그
> 벡터또는 행렬은 한개이상의 값을 가지기떄문에 각각 모두 계산해준다.

3. numpy.max() , numpy.min()
> 최댓값과 최솟값을 찾아줌

4. numpy.argmax() , numpy.argmin()
> 벡터에서 최댓값이 위치한 인덱스를 리턴
> 벡터에서 최솟값이 위치한 인덱스를 리턴	


최댓값과 최솟값의 인덱스를 행기준으로 찾고싶다면 

두번쨰 옵션으로 axis 를 1을 주면 찾을수있다.

열기준으로 찾고싶다면 axis = 0 을 주면된다.


5. numpy.ones() , numpy.zeros()
> 주어진 형상을 1로채우고
> 주어진 형상을 0으로 채운다.

ex)

numpy.ones([3,3])

[
	[1.	1.	1.]
>	[1.	1.	1.]
	[1.	1.	1.]
]


numpy.zeros([3,2])

[
	[0.	0.]
>	[0.	0.]
	[0.	0.]
]


numpy.argmax() , numpy.argmin() , numpy.max() , numpy.min()

ex)

	2	4	6
X =	1	2	3
	0	5	8





np.max(X)	> axis = 0	>	2	5	8

np.min(X) > axis = 0	>	0	2	3

np.max(X) > axis = 1	>	6	3	8

np.max(X) > axis = 1	>	2	1	0


np.armax(X) > axis = 0	>	0	2	2

np.armin(X) > axis = 0	>	2	1	1

np.armax(X) > axis = 1	>	2	2	2

np.armin(X) > axis = 1	>	0	0	0



@ scatter plot

> 실무에서는 머신러닝 코드를 구현하기 전에 입력 데이터의 분포와 모양을 먼저 그래프로 그려보고,
데이터의 특성과 분포를 파악 한 후 어떤알고리즘을 적용할지 결정하고 있다.

>> 데이터 시각화를 위해서는 matpoltilb 라이브러리를 사용한다.

> 일반적으로 line plot scatter plot 등을 통해 데이터의 분포와 형태를 파악한다.

ex)

import matplotlib.pyplot as plt
import numpy as np

>> show() 함수를 호출하기위해 tilte() , grid(), scatter(x데이터의범위,y데이터의범위,그래프의색깔,marke=''옵션) > 그래프의종류 

즉 show를 호출하기전에 세팅을 해준다.

scatter 대신 plot 를 호출할수있다.






