1. 9강 ~ 11강


## 수치미분


입력값 x가 변할떄 출력값 f(x)를 알수있다.



함수를 미분하라 라는 뜻이란?

>> 입력 변수 x가 미세하게 변할떄, 함수 f 가 얼마나 변하는지

함수 f(x) 는 입력 x의 미세한 변화에 얼마나 민감하게 반응하는지 알수있는 식을 구하라 라는 의미

입력 x를 현재값에서 아주 조금 변화시키면 함수 f(x)는 얼마나 변하는가?

함수 f(x)는 입력x의 미세한 변화에 얼마나 민감하게 반응하는가? 라는 의미

ex)

함수  f(x) - x**2 일경우 미분  f'(x) = 2x

f(3) = 9 해석

>> 입력 x=3 에서 출력은 9라는것을 의미

f'(3)= 9 해석

>> 입력 x=3을 미세하게 변화시킬떄 함수는 현재 입력값의 2배인 6배 변화를 일으킴을 의미한다.


@@@@머신러닝에서 사용하는 미분공식

f(x) = 상수 >> f'(x) = 0

f(x) = e**x >> f'(x) = e**x

f(x) = e**-x >> f'(x) = -e**-x

f(x) = ax**n >> f'(x) = nax**n-1

f(x) = ln x >> f'(x) = 1/x


ex) 문제

답

1. 6x + e**x

2. 1/x - x**-2 = 1/x - 1/x**2



편미분

>> 편미분은 입력변수가 하나 이상인 다변수 함수에서, 미분하고자 하는 변수 하나를 제외한 
나머지 변수들은 상수로 취급하고, 해당 변수를 미분하는것

>> 만약 x를 기준으로 미분을 한다면 나머지를 상수로 본다는 의미


ex) 샘플코드

체중 함수가 '체중(야식,운동)' 처럼 야식/운동에 영향을 받는 2변수 함수라고 가정할 경우,
편미분을 이용하면 각 변수 변화에 따라 체중 변화량을 구할 수 있다.

2가지 경우

1. 현재 먹는 야식의 양에서 조금 변화를 줄 경우 체중은 얼마나 변하는가? ( 야식기준 )

2. 현재 하고 있는 운동량에 조금 변화를 줄경우 체중은 얼마나 변하는가? ( 운동기준 )


@연쇄법칙

합성함수란 여러 함수로 구성된 함수로서, 이러한 합성함수를 미분하려면 '합성함수를 구성하는 
각 함수의 미분의 곱'으로 나타내는 연쇄법칙 이용

ex)

f(x) = e**3x**2	>>	함수 e**t , 함수 t=3x**2	조합한것

f(x) = e**-x	>>	함수 e**t , 함수 t=-x	조합한것


ex)

f(x) = e**3x**2 라면 t = 3x**2 라고두고 미분을 해준다

t' = 6x 이므로

f(x) = e**t 의 미분은 e**t 이다 따라서

e**t * 6x 이므로 == e**3x**2 * 6x == (6x)(e**3x**2)



@@@@@@@여기까지가 9강 내용@@@@@@@@@@@@

@ 수치 미분1차버전 

수치미분은 수학공식을 쓰지않고 C/파이썬 등을 이용하여, 주어진 입력값이 미세하게 변할때
함수 값 f 은 얼마나 변하는지를 수치적으로 계산해주는것을 지칭

ex)

def numerical_derivative(f,x):
	delta_x = 1e-4
	return (f(x+delta_x) - f(x-delta_x)) / (2*delta_x)



예제

함수  f(x) = x**2 에서 미분계수 f'(3)을 구하기. 즉 x=3 에서 값이 미세하게 변할때,
함수 f 는 얼마나 변하는지 계산

def my_func1(x):
	return x**2

def numerical_derivative(f,x):
	delta_x = 1e-4
	return (f(x+delta_x) - f(x-delta_x)) / (2*delta_x)

result = numerical_derivative(my_func1,3)

print("result == ", result)



출력 결과 

result == 6.000000000012662


ex) 예제 2

함수 f(x) = 3xe**x 를 미분한 함수를 f'(x) 라고 할 경우 f'(2) 을 ㄱ하기 x=2 에서 값이 미세하게 변할때,
함수 f는 얼마나 변하는지 계산하라는 의미

import numpy as np

def my_func2(x):
	return 3*x*(np.exp(x))

def numerical_derivative(f,x):
	delta_x = 1e-4
	return (f(x+delta_x) - f(x-delta_x)) / (2*delta_x)

result = numerical_derivative(my_func2,2)

print("result == ", result)

출력

result == 66.5015.....


print("3*exp(2) + 3*2*exp(2) ==", end=' ')
print(3*np.exp(2) + 3*2*np.exp(2))


@수치미분 최종버전

입력 변수가 하나 이상인 다변수 함수의 경우 , 입력변수는 서로 독립적이기 때문에 수치미분 또한 변수의 개수
만큼 개별적으로 계산하여야함


다변수 함수

ex)

import numpy as np

def numerical_derivative(f,x):	 # >> 다변수 함수 ,   (모든 변수를 포함하고 있는 numpy 객체)
	delta_x = 1e-4
	grad = np.zeros_like(x)	# 계산된 수치미분 값 저장 변수

	it = np.nditer(x, flags=['multi_index'], op_flages=['readwrite']	# 모든 입력변수에 대한 편미분하기 위해 iterator 획득

	while not it.findshed:	# 변수 개수만큼 반복
		idx = it.multi_index

		tmp_val = x[idx]	# numpy 타입은 mutable 이므로 원래값 보관

		x[idx] = float(tmp_val) + delta_x	#|
		fx1 = f(x)				#|
						#	하나의 변수에대한 수치미분 계산
		x[idx] = tmp_val - delta_x		#|		(기존코드와 동일)
		fx2 = f(x)				#|
		grea[idx] = (fx1 -fx2) / (2*delta_x)	#|

		x[idx] = tmp_val
		it.iternect()

	return grad


@@@@여기까지가 10강


import numpy as np

def numerical_derivative(f,x):	 #(모든 변수를 포함하고 있는 numpy 객체)
	delta_x = 1e-4
	grad = np.zeros_like(x)	# 입력 파라미터로 들어온 x에 대해서 수치미분을 계산하고 그 수치미분 값 저장하는 변수

	it = np.nditer(x, flags=['multi_index'], op_flages=['readwrite']	# 입력파라미터 각각의 요소를 가리키고있음
    # 따라서 순서적으로 편미분되는것을 볼수있음

	while not it.findshed:	# 변수 개수만큼 반복
		idx = it.multi_index

		tmp_val = x[idx]	

		x[idx] = float(tmp_val) + delta_x	
		fx1 = f(x)				
						
		x[idx] = tmp_val - delta_x		
		fx2 = f(x)				
		grea[idx] = (fx1 -fx2) / (2*delta_x)	

		x[idx] = tmp_val
		it.iternect()

	return grad


## 수치미분 예제


1. 변수함수 f(x) = x**2		,	f'(3.0)
>>

import numpy as np

def func1(input_obj):
    x=input_obj[0]

    return x**2


def numerical_derivative(f,x):	
	delta_x = 1e-4
	grad = np.zeros_like(x)
    
    print("debug 1. initial input variable =", x)
    print("debug 2. initial grad =", grad)
    print("========================================")

	it = np.nditer(x, flags=['multi_index'], op_flages=['readwrite']	# 

	while not it.findshed:	
		idx = it.multi_index

        print("debug 3. idx =", idx, ",[idx]=",x[idx])

		tmp_val = x[idx]	

		x[idx] = float(tmp_val) + delta_x	
		fx1 = f(x)				
						
		x[idx] = tmp_val - delta_x		
		fx2 = f(x)		    # f(x-delta_x)		
		grea[idx] = (fx1 -fx2) / (2*delta_x)	

        print("debug 2. grad[idx] =", grad[idx])
        print("debug 2. grad =", grad)
        print("========================================")

		x[idx] = tmp_val
		it.iternect()

	return grad


실행방법

numerical_derivative(func1,	np.array([3.0])





예제 2변수 함수

f(x,y) = 2x+ 3xy + y**3  ,	f'(1.0,2.0)

import numpy as np

def func1(input_obj):
    x=input_obj[0]
    y=input_obj[1]

    return (2*x + 3*x*y + np.power(y,3))


def numerical_derivative(f,x):	
	delta_x = 1e-4
	grad = np.zeros_like(x)
    
    print("debug 1. initial input variable =", x)
    print("debug 2. initial grad =", grad)
    print("========================================")

	it = np.nditer(x, flags=['multi_index'], op_flages=['readwrite']	# 

	while not it.findshed:	
		idx = it.multi_index

        print("debug 3. idx =", idx, ",[idx]=",x[idx])

		tmp_val = x[idx]	

		x[idx] = float(tmp_val) + delta_x	
		fx1 = f(x)				
						
		x[idx] = tmp_val - delta_x		
		fx2 = f(x)		    # f(x-delta_x)		
		grea[idx] = (fx1 -fx2) / (2*delta_x)	

        print("debug 2. grad[idx] =", grad[idx])
        print("debug 2. grad =", grad)
        print("========================================")

		x[idx] = tmp_val
		it.iternect()

	return grad



실행하려면

input = np.array([1.0 , 2.0])
numerical_derivative( func1 , input)





예제 4변수 함수

f(w,x,y,z) = wx + xyz + 3w + zy**2  ,	f'(1.0, 2.0, 3.0, 4.0)

import numpy as np

def func1(input_obj):
    w=input_obj[0,0]
    x=input_obj[0,1]
    y=input_obj[1,0]
    z=input_obj[1,1]

    return (w*x + x*y*z + 3*w + z*np.power(y,2))


def numerical_derivative(f,x):	
	delta_x = 1e-4
	grad = np.zeros_like(x)
    
    print("debug 1. initial input variable =", x)
    print("debug 2. initial grad =", grad)
    print("========================================")

	it = np.nditer(x, flags=['multi_index'], op_flages=['readwrite']	# 

	while not it.findshed:	
		idx = it.multi_index

        print("debug 3. idx =", idx, ",[idx]=",x[idx])

		tmp_val = x[idx]	

		x[idx] = float(tmp_val) + delta_x	
		fx1 = f(x)				
						
		x[idx] = tmp_val - delta_x		
		fx2 = f(x)		    # f(x-delta_x)		
		grea[idx] = (fx1 -fx2) / (2*delta_x)	

        print("debug 2. grad[idx] =", grad[idx])
        print("debug 2. grad =", grad)
        print("========================================")

		x[idx] = tmp_val
		it.iternect()

	return grad


출력하려면

input = np.array([1.0 , 2.0], [3.0,4.0])
numerical_derivative( func1 , input)


w변수 (0,0) >> x변수 (0,1) >> y변수 (1,0) >> z변수 (1,1)



@@ 여기까지가 11강



