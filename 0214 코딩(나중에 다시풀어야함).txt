(우분투 리눅스 닉네임 : choi  패스워드 : 0810)

나중에 다시풀자 이해가 잘안됨.



1. 탑


풀이


def solution(height):
    answer = []
    height.reverse()  #왜냐하면 오른쪽에서 왼쪽으로 송신을 진행하므로  
    for i in range(len(height)):
        count = 0  #송신하는 탑과 수신하는 탑의 차이(높이??)
        for j in range(i+1,len(height)):
            count +=1
            if height[i] < height[j]:
                answer.append(len(height)-j)
                break
            else:
                if count ==len(list(range(i+1,len(height)))): #수신하는 탑이 없이 끝까지 도달 했을 경우
                    answer.append(0)
                    break
    answer.append(0) #맨 왼쪽에 있던 탑은 항상 수신하는 탑이 없다.
    answer.reverse()
    return answer

*********************************************************************************************************
또다른 풀이

def solution(height):
    answer = []
    answer.append(0)
    
    for i in range(1, len(height)):
        
        flag = False
        
        for j in range(i-1,-1,-1):
            
            if height[j] > height[i]:
                answer.append(j+1)
                flag = False
                break
                
            else:
                flag = True
                
        if flag:
            answer.append(0)
            
    return answer

# answer이란 배열을 만들어놓고 맨처음 탑은 신호를 보낼탑이 없으므로 무조건 0이다. 
# 그리고 탑 왼쪽부터 로직을 수행하고 길이가 1부터이므로 1, len(height) 이다. 플래그가 True면 1을 반환
# False이면 0을 반환 따라서 왼쪽에있는 탑들이랑 높이를 비교하므로 (i-1, -1, -1) 이고 현재 기준탑보다
# 높은곳에 있다면 그탑에 신호를 보내고 탑의 위치에 answer 배열을 집어넣는다. 
# 신호를 보낼곳이 없거나 높은탑이 없으면 0값을 받는다.

2. 스킬트리


풀이


def solution(skill, skill_trees):
    answer = 0
    
    for i in skill_trees:
        idx = 0
        im = True
        for k in i:
            if k not in skill:			*****
                continue
            if idx < skill.index(k):			나중에 이부분 다시 이해
                im = False
                break				****
            else:
                idx +=1
        if im:
            answer +=1
            
    return answer



# answer 의값을 0으로 설정하고 스킬트리만큼 반복문을 돌린다. 인덱스는 0으로 설정하고 if문을 거치지
# 않는이상 항상 참으로 설정한다. 그리고 스킬트리안의 반복문이 또 돌면 스킬트리가 k안에 없을시
# 계속 해서 돌리고 idx값 즉 skill.index(k) k번쨰의 스킬이 없어서 스킬을 못배우므로 break
# 나머지의경우는 다 충족하므로 idx를 1씩 증가 이 반복문이 True라면 answer도 1씩 증가
# 그리고 answer을 리턴한다.


3. 다리를 지나는 트럭

(나중에 다시 이해하기)
풀이

from collections import deque


def solution(bridge_length, weight, truck_weights):
    sec = 1  # 처음부터 트럭을 다리에 올린다.
    s = truck_weights[0]  # 다리에 올라간 트럭의 총 무게
    truck_weights = deque(truck_weights)  # deque 자료구조화
    trucks_on_bridge = deque([[truck_weights[0], 1]])  # 다리에 올라간 트럭을 구분. (트럭 무게, 해당 트럭이 다리 위에 있는 시간)
    truck_idx = 1  # 다음에 다리에 오를 트럭을 가리킴

************ 설정값 *************
    while truck_weights:  # 올릴 트럭이 남아 있는 동안 반복
        sec += 1  # 1초 증가
        if truck_idx < len(truck_weights):  # 트럭을 이미 다 올려 트럭이 없으면 다리에 트럭 안올림
            if s + truck_weights[truck_idx] <= weight:  # 지금 올려야하는 트럭과 다리 위 트럭 무게 총합이 weight 이하면
                s += truck_weights[truck_idx]  # 트럭 올리기
                trucks_on_bridge.append([truck_weights[truck_idx], 0])  # 무게, 초
                truck_idx += 1  # 다음 트럭 가리킴
        for truck in trucks_on_bridge:  # 다리 위에 있는 모든 트럭에 대해
            truck[1] += 1  # 각 트럭이 다리 위에서 이동한 시간 1초 증가. 즉, 1칸 이동
        if trucks_on_bridge and trucks_on_bridge[0][1] == bridge_length:  # 맨 끝에 있는 트럭이 다리를 다 지났다면
            s -= trucks_on_bridge[0][0]  # 다리를 통과한 트럭 무게는 다리에 있는 트럭 무게 총합에서 빼기
            trucks_on_bridge.popleft()  # 다리 위 트럭 빼기
            truck_weights.popleft()  # 트럭 빼기
            truck_idx -= 1  # 트럭이 빠졌으므로 인덱스를 -1만큼 옮겨 다음에 올릴 트럭 포인터 유지하기
    sec += 1
    return sec

#  popleft()는 deque의 맨 앞에 값을 빼서 x로 지정해줌으로서 그 원소를 사용
#
#
#
#
#
************************************************************
이후 시간 되면 추가문제



